--- a/net/minecraft/client/Minecraft.java
+++ b/net/minecraft/client/Minecraft.java
@@ -13,6 +13,8 @@
 import com.mojang.authlib.properties.PropertyMap;
 import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
 import com.mojang.blaze3d.matrix.MatrixStack;
+import com.mojang.blaze3d.platform.GlStateManager;
+import com.mojang.blaze3d.platform.GlStateManager.FogMode;
 import com.mojang.blaze3d.platform.PlatformDescriptors;
 import com.mojang.blaze3d.systems.RenderSystem;
 import com.mojang.datafixers.DataFixer;
@@ -20,63 +22,18 @@
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.JsonOps;
 import com.mojang.serialization.Lifecycle;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.Proxy;
-import java.net.SocketAddress;
-import java.nio.ByteOrder;
-import java.text.DecimalFormat;
-import java.text.DecimalFormatSymbols;
-import java.text.SimpleDateFormat;
-import java.util.Collections;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.Queue;
-import java.util.UUID;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.function.Function;
-import java.util.function.Supplier;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockRenderType;
 import net.minecraft.block.BlockState;
-import net.minecraft.client.audio.BackgroundMusicSelector;
-import net.minecraft.client.audio.BackgroundMusicTracks;
-import net.minecraft.client.audio.MusicTicker;
-import net.minecraft.client.audio.SoundHandler;
+import net.minecraft.block.Blocks;
+import net.minecraft.client.audio.*;
 import net.minecraft.client.entity.player.ClientPlayerEntity;
-import net.minecraft.client.gui.DialogTexts;
-import net.minecraft.client.gui.FontRenderer;
-import net.minecraft.client.gui.IngameGui;
-import net.minecraft.client.gui.LoadingGui;
-import net.minecraft.client.gui.ResourceLoadProgressGui;
-import net.minecraft.client.gui.ScreenManager;
+import net.minecraft.client.gui.*;
 import net.minecraft.client.gui.advancements.AdvancementsScreen;
 import net.minecraft.client.gui.chat.NarratorChatListener;
 import net.minecraft.client.gui.fonts.FontResourceManager;
 import net.minecraft.client.gui.recipebook.RecipeList;
-import net.minecraft.client.gui.screen.ChatScreen;
-import net.minecraft.client.gui.screen.ConfirmBackupScreen;
-import net.minecraft.client.gui.screen.ConfirmScreen;
-import net.minecraft.client.gui.screen.ConnectingScreen;
-import net.minecraft.client.gui.screen.DatapackFailureScreen;
-import net.minecraft.client.gui.screen.DeathScreen;
-import net.minecraft.client.gui.screen.DirtMessageScreen;
-import net.minecraft.client.gui.screen.EditWorldScreen;
-import net.minecraft.client.gui.screen.IngameMenuScreen;
-import net.minecraft.client.gui.screen.MainMenuScreen;
-import net.minecraft.client.gui.screen.MemoryErrorScreen;
-import net.minecraft.client.gui.screen.MultiplayerScreen;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.screen.SleepInMultiplayerScreen;
-import net.minecraft.client.gui.screen.WinGameScreen;
-import net.minecraft.client.gui.screen.WorkingScreen;
-import net.minecraft.client.gui.screen.WorldLoadProgressScreen;
+import net.minecraft.client.gui.screen.*;
 import net.minecraft.client.gui.screen.inventory.CreativeScreen;
 import net.minecraft.client.gui.screen.inventory.InventoryScreen;
 import net.minecraft.client.gui.social.FilterManager;
@@ -89,20 +46,7 @@
 import net.minecraft.client.network.login.ClientLoginNetHandler;
 import net.minecraft.client.network.play.ClientPlayNetHandler;
 import net.minecraft.client.particle.ParticleManager;
-import net.minecraft.client.renderer.BlockModelShapes;
-import net.minecraft.client.renderer.BlockRendererDispatcher;
-import net.minecraft.client.renderer.BufferBuilder;
-import net.minecraft.client.renderer.FirstPersonRenderer;
-import net.minecraft.client.renderer.FogRenderer;
-import net.minecraft.client.renderer.GPUWarning;
-import net.minecraft.client.renderer.GameRenderer;
-import net.minecraft.client.renderer.IWindowEventListener;
-import net.minecraft.client.renderer.ItemRenderer;
-import net.minecraft.client.renderer.RenderTypeBuffers;
-import net.minecraft.client.renderer.ScreenSize;
-import net.minecraft.client.renderer.Tessellator;
-import net.minecraft.client.renderer.VirtualScreen;
-import net.minecraft.client.renderer.WorldRenderer;
+import net.minecraft.client.renderer.*;
 import net.minecraft.client.renderer.color.BlockColors;
 import net.minecraft.client.renderer.color.ItemColors;
 import net.minecraft.client.renderer.debug.DebugRenderer;
@@ -115,28 +59,11 @@
 import net.minecraft.client.renderer.texture.TextureManager;
 import net.minecraft.client.renderer.tileentity.TileEntityRendererDispatcher;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
-import net.minecraft.client.resources.DownloadingPackFinder;
-import net.minecraft.client.resources.FoliageColorReloadListener;
-import net.minecraft.client.resources.GrassColorReloadListener;
-import net.minecraft.client.resources.I18n;
-import net.minecraft.client.resources.LanguageManager;
-import net.minecraft.client.resources.LegacyResourcePackWrapper;
-import net.minecraft.client.resources.LegacyResourcePackWrapperV4;
-import net.minecraft.client.resources.SkinManager;
-import net.minecraft.client.settings.AmbientOcclusionStatus;
-import net.minecraft.client.settings.CloudOption;
-import net.minecraft.client.settings.CreativeSettings;
-import net.minecraft.client.settings.GraphicsFanciness;
-import net.minecraft.client.settings.KeyBinding;
-import net.minecraft.client.settings.PointOfView;
+import net.minecraft.client.resources.*;
+import net.minecraft.client.settings.*;
 import net.minecraft.client.shader.Framebuffer;
 import net.minecraft.client.tutorial.Tutorial;
-import net.minecraft.client.util.IMutableSearchTree;
-import net.minecraft.client.util.ITooltipFlag;
-import net.minecraft.client.util.SearchTree;
-import net.minecraft.client.util.SearchTreeManager;
-import net.minecraft.client.util.SearchTreeReloadable;
-import net.minecraft.client.util.Splashes;
+import net.minecraft.client.util.*;
 import net.minecraft.client.world.ClientWorld;
 import net.minecraft.command.Commands;
 import net.minecraft.crash.CrashReport;
@@ -144,51 +71,19 @@
 import net.minecraft.crash.ReportedException;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityType;
-import net.minecraft.entity.item.ArmorStandEntity;
-import net.minecraft.entity.item.BoatEntity;
-import net.minecraft.entity.item.EnderCrystalEntity;
-import net.minecraft.entity.item.ItemFrameEntity;
-import net.minecraft.entity.item.LeashKnotEntity;
-import net.minecraft.entity.item.PaintingEntity;
+import net.minecraft.entity.item.*;
 import net.minecraft.entity.item.minecart.AbstractMinecartEntity;
 import net.minecraft.entity.player.ChatVisibility;
-import net.minecraft.entity.player.PlayerEntity;
 import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemGroup;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.item.SkullItem;
-import net.minecraft.item.SpawnEggItem;
-import net.minecraft.nbt.CompoundNBT;
-import net.minecraft.nbt.INBT;
-import net.minecraft.nbt.ListNBT;
-import net.minecraft.nbt.NBTDynamicOps;
-import net.minecraft.nbt.StringNBT;
+import net.minecraft.item.*;
+import net.minecraft.nbt.*;
 import net.minecraft.network.NetworkManager;
 import net.minecraft.network.ProtocolType;
 import net.minecraft.network.handshake.client.CHandshakePacket;
 import net.minecraft.network.login.client.CLoginStartPacket;
 import net.minecraft.network.play.client.CPlayerDiggingPacket;
-import net.minecraft.profiler.DataPoint;
-import net.minecraft.profiler.EmptyProfiler;
-import net.minecraft.profiler.IProfileResult;
-import net.minecraft.profiler.IProfiler;
-import net.minecraft.profiler.ISnooperInfo;
-import net.minecraft.profiler.LongTickDetector;
-import net.minecraft.profiler.Snooper;
-import net.minecraft.profiler.TimeTracker;
-import net.minecraft.resources.DataPackRegistries;
-import net.minecraft.resources.FolderPackFinder;
-import net.minecraft.resources.IPackNameDecorator;
-import net.minecraft.resources.IReloadableResourceManager;
-import net.minecraft.resources.IResourceManager;
-import net.minecraft.resources.IResourcePack;
-import net.minecraft.resources.ResourcePackInfo;
-import net.minecraft.resources.ResourcePackList;
-import net.minecraft.resources.ResourcePackType;
-import net.minecraft.resources.ServerPackFinder;
-import net.minecraft.resources.SimpleReloadableResourceManager;
+import net.minecraft.profiler.*;
+import net.minecraft.resources.*;
 import net.minecraft.resources.data.PackMetadataSection;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.integrated.IntegratedServer;
@@ -196,35 +91,15 @@
 import net.minecraft.tags.ItemTags;
 import net.minecraft.tileentity.SkullTileEntity;
 import net.minecraft.tileentity.TileEntity;
-import net.minecraft.util.ActionResultType;
-import net.minecraft.util.Direction;
-import net.minecraft.util.FrameTimer;
-import net.minecraft.util.Hand;
-import net.minecraft.util.NonNullList;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.Session;
-import net.minecraft.util.SharedConstants;
 import net.minecraft.util.Timer;
-import net.minecraft.util.Unit;
-import net.minecraft.util.Util;
+import net.minecraft.util.*;
 import net.minecraft.util.concurrent.RecursiveEventLoop;
 import net.minecraft.util.datafix.DataFixesManager;
 import net.minecraft.util.datafix.codec.DatapackCodec;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.BlockRayTraceResult;
-import net.minecraft.util.math.EntityRayTraceResult;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.RayTraceResult;
-import net.minecraft.util.registry.Bootstrap;
-import net.minecraft.util.registry.DynamicRegistries;
-import net.minecraft.util.registry.Registry;
-import net.minecraft.util.registry.WorldGenSettingsExport;
-import net.minecraft.util.registry.WorldSettingsImport;
-import net.minecraft.util.text.ITextComponent;
-import net.minecraft.util.text.KeybindTextComponent;
-import net.minecraft.util.text.StringTextComponent;
-import net.minecraft.util.text.TextFormatting;
-import net.minecraft.util.text.TranslationTextComponent;
+import net.minecraft.util.math.*;
+import net.minecraft.util.math.vector.Vector3d;
+import net.minecraft.util.registry.*;
+import net.minecraft.util.text.*;
 import net.minecraft.world.World;
 import net.minecraft.world.WorldSettings;
 import net.minecraft.world.biome.Biome;
@@ -235,22 +110,96 @@
 import net.minecraft.world.storage.IServerConfiguration;
 import net.minecraft.world.storage.SaveFormat;
 import net.minecraft.world.storage.ServerWorldInfo;
+import net.optifine.Config;
+import net.optifine.reflect.Reflector;
+import net.optifine.shaders.Shaders;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.lwjgl.opengl.ARBShaderObjects;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL13;
+import org.vivecraft.api.ErrorHelper;
+import org.vivecraft.api.NetworkHelper;
+import org.vivecraft.control.VRInputAction;
+import org.vivecraft.gameplay.OpenVRPlayer;
+import org.vivecraft.gameplay.screenhandlers.GuiHandler;
+import org.vivecraft.gameplay.screenhandlers.KeyboardHandler;
+import org.vivecraft.gameplay.screenhandlers.RadialHandler;
+import org.vivecraft.gameplay.trackers.*;
+import org.vivecraft.gui.physical.PhysicalGuiManager;
+import org.vivecraft.menuworlds.MenuWorldRenderer;
+import org.vivecraft.provider.MCOpenVR;
+import org.vivecraft.provider.OpenVRStereoRenderer;
+import org.vivecraft.render.*;
+import org.vivecraft.settings.VRHotkeys;
+import org.vivecraft.settings.VRSettings;
+import org.vivecraft.settings.VRSettings.VrOptions;
+import org.vivecraft.utils.LangHelper;
+import org.vivecraft.utils.Utils;
+import org.vivecraft.utils.lwjgl.Matrix4f;
+import org.vivecraft.utils.math.Vector3;
 
-public class Minecraft extends RecursiveEventLoop<Runnable> implements ISnooperInfo, IWindowEventListener
-{
-    private static Minecraft instance;
-    private static final Logger LOGGER = LogManager.getLogger();
+import javax.annotation.Nullable;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.net.Proxy;
+import java.net.SocketAddress;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
+import java.text.SimpleDateFormat;
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
+
+public class Minecraft extends RecursiveEventLoop<Runnable> implements ISnooperInfo, IWindowEventListener {
     public static final boolean IS_RUNNING_ON_MAC = Util.getOSType() == Util.OS.OSX;
     public static final ResourceLocation DEFAULT_FONT_RENDERER_NAME = new ResourceLocation("default");
     public static final ResourceLocation UNIFORM_FONT_RENDERER_NAME = new ResourceLocation("uniform");
     public static final ResourceLocation standardGalacticFontRenderer = new ResourceLocation("alt");
+    /**
+     * END MINECRIFT
+     */
+    private static final Logger LOGGER = LogManager.getLogger();
     private static final CompletableFuture<Unit> RESOURCE_RELOAD_INIT_TASK = CompletableFuture.completedFuture(Unit.INSTANCE);
     private static final ITextComponent field_244596_I = new TranslationTextComponent("multiplayer.socialInteractions.not_available");
+    public static byte[] memoryReserve = new byte[10485760];
+    private static Minecraft instance;
+    private static int debugFPS;
+    public final float PIOVER180 = (float) (Math.PI / 180);
+    /*
+     * The minecriftVerString will be automatically updated by the build scripts, do
+     * not modify here. Modify minecriftversion.py in root minecrift dir.
+     */
+    public final String minecriftVerString = "Vivecraft 1.16.5 jrbudda-7-4";
+    public final WorldRenderer worldRenderer;
+    public final ParticleManager particles;
+    public final FontRenderer fontRenderer;
+    public final GameRenderer gameRenderer;
+    public final DebugRenderer debugRenderer;
+    public final IngameGui ingameGUI;
+    public final MouseHelper mouseHelper;
+    public final KeyboardListener keyboardListener;
+    // VIVE END - teleport movement
+    public final File gameDir;
+    /**
+     * The FrameTimer's instance
+     */
+    public final FrameTimer frameTimer = new FrameTimer();
     private final File fileResourcepacks;
-
-    /** The player's GameProfile properties */
+    /**
+     * The player's GameProfile properties
+     */
     private final PropertyMap profileProperties;
     private final TextureManager textureManager;
     private final DataFixer dataFixer;
@@ -259,30 +208,17 @@
     private final Timer timer = new Timer(20.0F, 0L);
     private final Snooper snooper = new Snooper("client", this, Util.milliTime());
     private final RenderTypeBuffers renderTypeBuffers;
-    public final WorldRenderer worldRenderer;
     private final EntityRendererManager renderManager;
     private final ItemRenderer itemRenderer;
     private final FirstPersonRenderer firstPersonRenderer;
-    public final ParticleManager particles;
     private final SearchTreeManager searchTreeManager = new SearchTreeManager();
     private final Session session;
-    public final FontRenderer fontRenderer;
-    public final GameRenderer gameRenderer;
-    public final DebugRenderer debugRenderer;
     private final AtomicReference<TrackingChunkStatusListener> refChunkStatusListener = new AtomicReference<>();
-    public final IngameGui ingameGUI;
-    public final GameSettings gameSettings;
     private final CreativeSettings creativeSettings;
-    public final MouseHelper mouseHelper;
-    public final KeyboardListener keyboardListener;
-    public final File gameDir;
     private final String launchedVersion;
     private final String versionType;
     private final Proxy proxy;
     private final SaveFormat saveFormat;
-
-    /** The FrameTimer's instance */
-    public final FrameTimer frameTimer = new FrameTimer();
     private final boolean jvm64bit;
     private final boolean isDemo;
     private final boolean enableMultiplayer;
@@ -293,9 +229,9 @@
     private final LanguageManager languageManager;
     private final BlockColors blockColors;
     private final ItemColors itemColors;
-    private final Framebuffer framebuffer;
     private final SoundHandler soundHandler;
     private final MusicTicker musicTicker;
+    /* end version */
     private final FontResourceManager fontResourceMananger;
     private final Splashes splashes;
     private final GPUWarning warningGPU;
@@ -303,7 +239,6 @@
     private final SocialInteractionsService field_244734_au;
     private final SkinManager skinManager;
     private final ModelManager modelManager;
-
     /**
      * The BlockRenderDispatcher instance that will be used based off gamesettings
      */
@@ -314,7 +249,63 @@
     private final MinecraftGame game = new MinecraftGame(this);
     private final Tutorial tutorial;
     private final FilterManager field_244597_aC;
-    public static byte[] memoryReserve = new byte[10485760];
+    private final Queue<Runnable> queueChunkTracking = Queues.newConcurrentLinkedQueue();
+    private final FloatBuffer matrixBuffer = GLAllocation.createDirectFloatBuffer(16);
+    private final FloatBuffer matrixBuffer2 = GLAllocation.createDirectFloatBuffer(16);
+    private final boolean firstInit = true;
+    private final float splashFadeAlpha = 0;
+    // VIVE START - teleport movement
+    public OpenVRPlayer vrPlayer;
+    public BackpackTracker backpackTracker = new BackpackTracker(this);
+    public BowTracker bowTracker = new BowTracker(this);
+    public SwimTracker swimTracker = new SwimTracker(this);
+    public EatingTracker autoFood = new EatingTracker(this);
+    public JumpTracker jumpTracker = new JumpTracker(this);
+    public SneakTracker sneakTracker = new SneakTracker(this);
+    public ClimbTracker climbTracker = new ClimbTracker(this);
+    public RunTracker runTracker = new RunTracker(this);
+    public RowTracker rowTracker = new RowTracker(this);
+    public TeleportTracker teleportTracker = new TeleportTracker(this);
+    public SwingTracker swingTracker = new SwingTracker(this);
+    public HorseTracker horseTracker = new HorseTracker(this);
+    public VehicleTracker vehicleTracker = new VehicleTracker(this);
+    public PhysicalGuiManager physicalGuiManager = new PhysicalGuiManager(this);
+    public InteractTracker interactTracker = new InteractTracker(this);
+    public CrawlTracker crawlTracker = new CrawlTracker(this);
+    public CameraTracker cameraTracker = new CameraTracker(this);
+    public ThreadGroup backgroundThreadGroup = new ThreadGroup("background");
+    /**
+     * MINECRIFT
+     */
+
+    public boolean minecriftDebug = false;
+    public int lastShaderIndex = -1;
+    public Field fieldHwnd = null;
+    public Field fieldDisplay = null;
+    public Field fieldWindow = null;
+    public Field fieldResized = null;
+    public Method fieldResizedMethod = null;
+    public OpenVRStereoRenderer stereoProvider;
+    public VRSettings vrSettings;
+    public long lastIntegratedServerLaunchCheck = 0;
+    public boolean integratedServerLaunchInProgress = false;
+    public boolean grabScreenShot = false;
+    public boolean lastShowMouseNative = true;
+    public boolean enableWorldExport = false;
+    public SoundEngine sndManager = null;
+    public MenuWorldRenderer menuWorldRenderer;
+    public boolean showSplashScreen = true;
+    public long splashTimer1 = 0;
+    public long splashTimer2 = 0;
+    public Deque<Long> runTickTimeNanos = new ArrayDeque<>();
+    public long medianRunTickTimeNanos = 0;
+    public long frameIndex = 0;
+    public ErrorHelper errorHelper;
+    public RenderPass currentPass;
+    public boolean resourcePacksChanged;
+    public int tickCounter;
+    public GameSettings gameSettings;
+    public Framebuffer framebuffer;
     @Nullable
     public PlayerController playerController;
     @Nullable
@@ -322,46 +313,53 @@
     @Nullable
     public ClientPlayerEntity player;
     @Nullable
+    public Entity renderViewEntity;
+    @Nullable
+    public Entity pointedEntity;
+    @Nullable
+    public RayTraceResult objectMouseOver;
+    public boolean skipRenderWorld;
+    @Nullable
+    public Screen currentScreen;
+    @Nullable
+    public LoadingGui loadingGui;
+    public String debug = "";
+    public boolean debugWireframe;
+    public boolean debugChunkPath;
+    public boolean renderChunksMany = true;
+    public float watereffect, portaleffect, pumpkineffect;
+    protected int leftClickCounter;
+    long mirroNotifyStart;
+    String mirrorNotifyText;
+    boolean mirrorNotifyClear;
+    long mirroNotifyLen;
+    private Framebuffer splash;
+    private boolean lastClick;
+    @Nullable
     private IntegratedServer integratedServer;
     @Nullable
     private ServerData currentServerData;
     @Nullable
     private NetworkManager networkManager;
     private boolean integratedServerIsRunning;
-    @Nullable
-    public Entity renderViewEntity;
-    @Nullable
-    public Entity pointedEntity;
-    @Nullable
-    public RayTraceResult objectMouseOver;
     private int rightClickDelayTimer;
-    protected int leftClickCounter;
     private boolean isGamePaused;
     private float renderPartialTicksPaused;
-
-    /** Time in nanoseconds of when the class is loaded */
+    /**
+     * Time in nanoseconds of when the class is loaded
+     */
     private long startNanoTime = Util.nanoTime();
     private long debugUpdateTime;
     private int fpsCounter;
-    public boolean skipRenderWorld;
-    @Nullable
-    public Screen currentScreen;
-    @Nullable
-    public LoadingGui loadingGui;
-
-    /** True if the player is connected to a realms server */
+    /**
+     * True if the player is connected to a realms server
+     */
     private boolean connectedToRealms;
     private Thread thread;
     private volatile boolean running = true;
     @Nullable
     private CrashReport crashReporter;
-    private static int debugFPS;
-    public String debug = "";
-    public boolean debugWireframe;
-    public boolean debugChunkPath;
-    public boolean renderChunksMany = true;
     private boolean isWindowFocused;
-    private final Queue<Runnable> queueChunkTracking = Queues.newConcurrentLinkedQueue();
     @Nullable
     private CompletableFuture<Void> futureRefreshResources;
     @Nullable
@@ -369,17 +367,19 @@
     private IProfiler profiler = EmptyProfiler.INSTANCE;
     private int gameTime;
     private final TimeTracker gameTimeTracker = new TimeTracker(Util.nanoTimeSupplier, () ->
-    {
-        return this.gameTime;
-    });
+            this.gameTime);
     @Nullable
     private IProfileResult profilerResult;
     private String debugProfilerName = "root";
+    private float fov = 1.0f;
+    private float frameDelta, prevFrameTime;
 
-    public Minecraft(GameConfiguration gameConfig)
-    {
+    public Minecraft(GameConfiguration gameConfig) {
         super("Client");
         instance = this;
+        //Forge
+        Reflector.call(Reflector.ForgeHooksClient_invalidateLog4jThreadCache);
+        //
         this.gameDir = gameConfig.folderInfo.gameDir;
         File file1 = gameConfig.folderInfo.assetsDir;
         this.fileResourcepacks = gameConfig.folderInfo.resourcePacksDir;
@@ -393,8 +393,9 @@
         this.sessionService = yggdrasilauthenticationservice.createMinecraftSessionService();
         this.field_244734_au = this.func_244735_a(yggdrasilauthenticationservice, gameConfig);
         this.session = gameConfig.userInfo.session;
-        LOGGER.info("Setting user: {}", (Object)this.session.getUsername());
-        LOGGER.debug("(Session ID is {})", (Object)this.session.getSessionID());
+        //Forge
+        //LOGGER.debug("(Session ID is {})", (Object)this.session.getSessionID());
+        //
         this.isDemo = gameConfig.gameInfo.isDemo;
         this.enableMultiplayer = !gameConfig.gameInfo.disableMultiplayer;
         this.enableChat = !gameConfig.gameInfo.disableChat;
@@ -403,13 +404,10 @@
         String s;
         int i;
 
-        if (this.isMultiplayerEnabled() && gameConfig.serverInfo.serverName != null)
-        {
+        if (this.isMultiplayerEnabled() && gameConfig.serverInfo.serverName != null) {
             s = gameConfig.serverInfo.serverName;
             i = gameConfig.serverInfo.serverPort;
-        }
-        else
-        {
+        } else {
             s = null;
             i = 0;
         }
@@ -418,18 +416,23 @@
         this.dataFixer = DataFixesManager.getDataFixer();
         this.toastGui = new ToastGui(this);
         this.tutorial = new Tutorial(this);
+        /** MINECRIFT **/
+        VRSettings.initSettings(this, gameDir);
+        if (!vrSettings.badStereoProviderPluginID.isEmpty()) {
+            vrSettings.stereoProviderPluginID = vrSettings.badStereoProviderPluginID;
+            vrSettings.badStereoProviderPluginID = "";
+            vrSettings.saveOptions();
+        }
+        /** END MINECRIFT **/
         this.thread = Thread.currentThread();
         this.gameSettings = new GameSettings(this, this.gameDir);
         this.creativeSettings = new CreativeSettings(this.gameDir, this.dataFixer);
-        LOGGER.info("Backend library: {}", (Object)RenderSystem.getBackendDescription());
+        LOGGER.info("Backend library: {}", RenderSystem.getBackendDescription());
         ScreenSize screensize;
 
-        if (this.gameSettings.overrideHeight > 0 && this.gameSettings.overrideWidth > 0)
-        {
+        if (this.gameSettings.overrideHeight > 0 && this.gameSettings.overrideWidth > 0) {
             screensize = new ScreenSize(this.gameSettings.overrideWidth, this.gameSettings.overrideHeight, gameConfig.displayInfo.fullscreenWidth, gameConfig.displayInfo.fullscreenHeight, gameConfig.displayInfo.fullscreen);
-        }
-        else
-        {
+        } else {
             screensize = gameConfig.displayInfo;
         }
 
@@ -438,26 +441,27 @@
         this.mainWindow = this.virtualScreen.create(screensize, this.gameSettings.fullscreenResolution, this.getWindowTitle());
         this.setGameFocused(true);
 
-        try
-        {
+        try {
             InputStream inputstream = this.getPackFinder().getVanillaPack().getResourceStream(ResourcePackType.CLIENT_RESOURCES, new ResourceLocation("icons/icon_16x16.png"));
             InputStream inputstream1 = this.getPackFinder().getVanillaPack().getResourceStream(ResourcePackType.CLIENT_RESOURCES, new ResourceLocation("icons/icon_32x32.png"));
             this.mainWindow.setWindowIcon(inputstream, inputstream1);
-        }
-        catch (IOException ioexception)
-        {
-            LOGGER.error("Couldn't set icon", (Throwable)ioexception);
+        } catch (IOException ioexception) {
+            LOGGER.error("Couldn't set icon", ioexception);
         }
 
         this.mainWindow.setFramerateLimit(this.gameSettings.framerateLimit);
         this.mouseHelper = new MouseHelper(this);
-        this.mouseHelper.registerCallbacks(this.mainWindow.getHandle());
+        //       this.mouseHelper.registerCallbacks(this.mainWindow.getHandle());
         this.keyboardListener = new KeyboardListener(this);
         this.keyboardListener.setupCallbacks(this.mainWindow.getHandle());
         RenderSystem.initRenderer(this.gameSettings.glDebugVerbosity, false);
-        this.framebuffer = new Framebuffer(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight(), true, IS_RUNNING_ON_MAC);
+        //I would prefer to comment this out to ensure it isnt used, but Forge needs it or whatever.
+        this.framebuffer = new Framebuffer(this.mainWindow.getWidth(), this.mainWindow.getHeight(), true, IS_RUNNING_ON_MAC);
         this.framebuffer.setFramebufferColor(0.0F, 0.0F, 0.0F, 0.0F);
         this.resourceManager = new SimpleReloadableResourceManager(ResourcePackType.CLIENT_RESOURCES);
+        //Forge
+        Reflector.call(Reflector.ClientModLoader_begin, this, this.resourcePackRepository, this.resourceManager, this.packFinder);
+        //
         this.resourcePackRepository.reloadPacksFromFinders();
         this.gameSettings.fillResourcePackList(this.resourcePackRepository);
         this.languageManager = new LanguageManager(this.gameSettings.language);
@@ -475,6 +479,13 @@
         this.fontRenderer = this.fontResourceMananger.func_238548_a_();
         this.resourceManager.addReloadListener(this.fontResourceMananger.getReloadListener());
         this.forceUnicodeFont(this.getForceUnicodeFont());
+        /** MINECRIFT */
+        try {
+            initMinecrift();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        /** END MINECRIFT */
         this.resourceManager.addReloadListener(new GrassColorReloadListener());
         this.resourceManager.addReloadListener(new FoliageColorReloadListener());
         this.mainWindow.setRenderPhase("Startup");
@@ -499,6 +510,9 @@
         this.populateSearchTreeManager();
         this.resourceManager.addReloadListener(this.searchTreeManager);
         this.particles = new ParticleManager(this.world, this.textureManager);
+        //Forge
+        Reflector.call(Reflector.call(Reflector.fml_ModLoader_get), Reflector.fml_ModLoader_postEvent, Reflector.newInstance(Reflector.ParticleFactoryRegisterEvent_Constructor));
+        //
         this.resourceManager.addReloadListener(this.particles);
         this.paintingSprites = new PaintingSpriteUploader(this.textureManager);
         this.resourceManager.addReloadListener(this.paintingSprites);
@@ -506,12 +520,20 @@
         this.resourceManager.addReloadListener(this.potionSprites);
         this.warningGPU = new GPUWarning();
         this.resourceManager.addReloadListener(this.warningGPU);
-        this.ingameGUI = new IngameGui(this);
+        //Forge
+        if (Reflector.ForgeIngameGui_Constructor.exists())
+            this.ingameGUI = (IngameGui) Reflector.newInstance(Reflector.ForgeIngameGui_Constructor, this);
+        else
+            this.ingameGUI = new IngameGui(this);
+        //Forge
+
+        //Forge
+        this.mouseHelper.registerCallbacks(this.mainWindow.getHandle()); //Forge: Moved below ingameGUI setting to prevent NPEs in handeler.
+        //
         this.debugRenderer = new DebugRenderer(this);
         RenderSystem.setErrorCallback(this::disableVSyncAfterGlError);
 
-        if (this.gameSettings.fullscreen && !this.mainWindow.isFullscreen())
-        {
+        if (this.gameSettings.fullscreen && !this.mainWindow.isFullscreen()) {
             this.mainWindow.toggleFullscreen();
             this.gameSettings.fullscreen = this.mainWindow.isFullscreen();
         }
@@ -521,144 +543,323 @@
         this.mainWindow.setLogOnGlError();
         this.updateWindowSize();
 
-        if (s != null)
-        {
-            this.displayGuiScreen(new ConnectingScreen(new MainMenuScreen(), this, s, i));
-        }
-        else
-        {
-            this.displayGuiScreen(new MainMenuScreen(true));
-        }
+        final String autoServerName = s;
+        final int autoServerPort = i;
+        //
+
+        // VIVE
+        menuWorldRenderer = new MenuWorldRenderer();
+        vrSettings.firstRun = false;
+        vrSettings.saveOptions();
+        // END VIVE
+
 
         ResourceLoadProgressGui.loadLogoTexture(this);
         List<IResourcePack> list = this.resourcePackRepository.func_232623_f_();
         this.setLoadingGui(new ResourceLoadProgressGui(this, this.resourceManager.reloadResources(Util.getServerExecutor(), this, RESOURCE_RELOAD_INIT_TASK, list), (throwable) ->
         {
+            // Vivecraft - post load
+            if (stereoProvider.isInitialized())
+                menuWorldRenderer.init();
+
+            MCOpenVR.initInputAndApplication();
+            //
             Util.acceptOrElse(throwable, this::restoreResourcePacks, () -> {
-                if (SharedConstants.developmentMode)
-                {
+                if (SharedConstants.developmentMode) {
                     this.checkMissingData();
                 }
+                //Forge
+
+                if (Reflector.callBoolean(Reflector.ClientModLoader_completeModLoading))
+                    return; // Do not overwrite the error screen
+                // FORGE: Move opening initial screen to after startup and events are enabled.
+                // Also Fixes MC-145102
+                if (autoServerName != null) {
+                    this.displayGuiScreen(new ConnectingScreen(new MainMenuScreen(), this, autoServerName, autoServerPort));
+                } else {
+                    this.displayGuiScreen(new MainMenuScreen(true));
+                }
+                //
             });
         }, false));
     }
 
-    public void setDefaultMinecraftTitle()
-    {
-        this.mainWindow.setWindowTitle(this.getWindowTitle());
-    }
+    private static boolean isJvm64bit() {
+        String[] astring = new String[]{"sun.arch.data.model", "com.ibm.vm.bitmode", "os.arch"};
 
-    private String getWindowTitle()
-    {
-        StringBuilder stringbuilder = new StringBuilder("Minecraft");
+        for (String s : astring) {
+            String s1 = System.getProperty(s);
 
-        if (this.isModdedClient())
-        {
-            stringbuilder.append("*");
+            if (s1 != null && s1.contains("64")) {
+                return true;
+            }
         }
 
-        stringbuilder.append(" ");
-        stringbuilder.append(SharedConstants.getVersion().getName());
-        ClientPlayNetHandler clientplaynethandler = this.getConnection();
+        return false;
+    }
 
-        if (clientplaynethandler != null && clientplaynethandler.getNetworkManager().isChannelOpen())
-        {
-            stringbuilder.append(" - ");
+    /**
+     * Wrapper around displayCrashReportInternal
+     */
+    public static void displayCrashReport(CrashReport report) {
+        File file1 = new File(getInstance().gameDir, "crash-reports");
+        File file2 = new File(file1, "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-client.txt");
+        Bootstrap.printToSYSOUT(report.getCompleteReport());
 
-            if (this.integratedServer != null && !this.integratedServer.getPublic())
-            {
-                stringbuilder.append(I18n.format("title.singleplayer"));
-            }
-            else if (this.isConnectedToRealms())
-            {
-                stringbuilder.append(I18n.format("title.multiplayer.realms"));
-            }
-            else if (this.integratedServer == null && (this.currentServerData == null || !this.currentServerData.isOnLAN()))
-            {
-                stringbuilder.append(I18n.format("title.multiplayer.other"));
-            }
+        if (report.getFile() != null) {
+            Bootstrap.printToSYSOUT("#@!@# Game crashed! Crash report saved to: #@!@# " + report.getFile());
+            if (Reflector.ServerLifecycleHooks_handleExit.exists())
+                Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -1);
             else
-            {
-                stringbuilder.append(I18n.format("title.multiplayer.lan"));
-            }
+                System.exit(-1);
+        } else if (report.saveToFile(file2)) {
+            Bootstrap.printToSYSOUT("#@!@# Game crashed! Crash report saved to: #@!@# " + file2.getAbsolutePath());
+            if (Reflector.ServerLifecycleHooks_handleExit.exists())
+                Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -1);
+            else
+                System.exit(-1);
+        } else {
+            Bootstrap.printToSYSOUT("#@?@# Game crashed! Crash report could not be saved. #@?@#");
+            if (Reflector.ServerLifecycleHooks_handleExit.exists())
+                Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -2);
+            else
+                System.exit(-2);
         }
-
-        return stringbuilder.toString();
     }
 
-    private SocialInteractionsService func_244735_a(YggdrasilAuthenticationService p_244735_1_, GameConfiguration p_244735_2_)
-    {
-        try
-        {
-            return p_244735_1_.createSocialInteractionsService(p_244735_2_.userInfo.session.getToken());
+    public static DatapackCodec loadDataPackCodec(SaveFormat.LevelSave worldStorage) {
+        MinecraftServer.func_240777_a_(worldStorage);
+        DatapackCodec datapackcodec = worldStorage.readDatapackCodec();
+
+        if (datapackcodec == null) {
+            throw new IllegalStateException("Failed to load data pack config");
+        } else {
+            return datapackcodec;
         }
-        catch (AuthenticationException authenticationexception)
-        {
-            LOGGER.error("Failed to verify authentication", (Throwable)authenticationexception);
-            return new OfflineSocialInteractions();
+    }
+
+    public static IServerConfiguration loadWorld(SaveFormat.LevelSave worldStorage, DynamicRegistries.Impl dynamicRegistries, IResourceManager resourceManager, DatapackCodec datapackCodec) {
+        WorldSettingsImport<INBT> worldsettingsimport = WorldSettingsImport.create(NBTDynamicOps.INSTANCE, resourceManager, dynamicRegistries);
+        IServerConfiguration iserverconfiguration = worldStorage.readServerConfiguration(worldsettingsimport, datapackCodec);
+
+        if (iserverconfiguration == null) {
+            throw new IllegalStateException("Failed to load world");
+        } else {
+            return iserverconfiguration;
         }
     }
 
-    public boolean isModdedClient()
-    {
-        return !"vanilla".equals(ClientBrandRetriever.getClientModName()) || Minecraft.class.getSigners() == null;
+    public static boolean isGuiEnabled() {
+        return !instance.gameSettings.hideGUI;
     }
 
-    private void restoreResourcePacks(Throwable throwableIn)
-    {
-        if (this.resourcePackRepository.func_232621_d_().size() > 1)
-        {
-            ITextComponent itextcomponent;
+    public static boolean isFancyGraphicsEnabled() {
+        return instance.gameSettings.graphicFanciness.func_238162_a_() >= GraphicsFanciness.FANCY.func_238162_a_();
+    }
 
-            if (throwableIn instanceof SimpleReloadableResourceManager.FailedPackException)
-            {
-                itextcomponent = new StringTextComponent(((SimpleReloadableResourceManager.FailedPackException)throwableIn).getPack().getName());
-            }
-            else
-            {
-                itextcomponent = null;
-            }
+    public static boolean isFabulousGraphicsEnabled() {
+        return instance.gameSettings.graphicFanciness.func_238162_a_() >= GraphicsFanciness.FABULOUS.func_238162_a_();
+    }
 
-            this.throwResourcePackLoadError(throwableIn, itextcomponent);
-        }
-        else
-        {
-            Util.toRuntimeException(throwableIn);
-        }
+    /**
+     * Returns if ambient occlusion is enabled
+     */
+    public static boolean isAmbientOcclusionEnabled() {
+        return instance.gameSettings.ambientOcclusionStatus != AmbientOcclusionStatus.OFF;
     }
 
-    public void throwResourcePackLoadError(Throwable throwable, @Nullable ITextComponent errorMessage)
-    {
-        LOGGER.info("Caught error loading resourcepacks, removing all selected resourcepacks", throwable);
-        this.resourcePackRepository.setEnabledPacks(Collections.emptyList());
-        this.gameSettings.resourcePacks.clear();
-        this.gameSettings.incompatibleResourcePacks.clear();
-        this.gameSettings.saveOptions();
-        this.reloadResources().thenRun(() ->
+    public static void fillCrashReport(@Nullable LanguageManager languageManagerIn, String versionIn, @Nullable GameSettings settingsIn, CrashReport crashReportIn) {
+        CrashReportCategory crashreportcategory = crashReportIn.getCategory();
+        crashreportcategory.addDetail("Launched Version", () ->
+                versionIn);
+        crashreportcategory.addDetail("Backend library", RenderSystem::getBackendDescription);
+        crashreportcategory.addDetail("Backend API", RenderSystem::getApiDescription);
+        crashreportcategory.addDetail("GL Caps", RenderSystem::getCapsString);
+        crashreportcategory.addDetail("Using VBOs", () ->
+                "Yes");
+        crashreportcategory.addDetail("Is Modded", () ->
         {
-            ToastGui toastgui = this.getToastGui();
-            SystemToast.addOrUpdate(toastgui, SystemToast.Type.PACK_LOAD_FAILURE, new TranslationTextComponent("resourcePack.load_fail"), errorMessage);
+            String s1 = ClientBrandRetriever.getClientModName();
+
+            if (!"vanilla".equals(s1)) {
+                return "Definitely; Client brand changed to '" + s1 + "'";
+            } else {
+                return Minecraft.class.getSigners() == null ? "Very likely; Jar signature invalidated" : "Probably not. Jar signature remains and client brand is untouched.";
+            }
         });
-    }
+        crashreportcategory.addDetail("Type", "Client (map_client.txt)");
 
-    public void run()
-    {
-        this.thread = Thread.currentThread();
+        if (settingsIn != null) {
+            if (instance != null) {
+                String s = instance.getGPUWarning().func_243499_m();
 
-        try
-        {
-            boolean flag = false;
+                if (s != null) {
+                    crashreportcategory.addDetail("GPU Warnings", s);
+                }
+            }
 
-            while (this.running)
+            crashreportcategory.addDetail("Graphics mode", settingsIn.graphicFanciness);
+            crashreportcategory.addDetail("Resource Packs", () ->
             {
-                if (this.crashReporter != null)
-                {
+                StringBuilder stringbuilder = new StringBuilder();
+
+                for (String s1 : settingsIn.resourcePacks) {
+                    if (stringbuilder.length() > 0) {
+                        stringbuilder.append(", ");
+                    }
+
+                    stringbuilder.append(s1);
+
+                    if (settingsIn.incompatibleResourcePacks.contains(s1)) {
+                        stringbuilder.append(" (incompatible)");
+                    }
+                }
+
+                return stringbuilder.toString();
+            });
+        }
+
+        if (languageManagerIn != null) {
+            crashreportcategory.addDetail("Current Language", () ->
+                    languageManagerIn.getCurrentLanguage().toString());
+        }
+
+        crashreportcategory.addDetail("CPU", PlatformDescriptors::getCpuInfo);
+    }
+
+    /**
+     * Return the singleton Minecraft instance for the game
+     */
+    public static Minecraft getInstance() {
+        return instance;
+    }
+
+    private static ResourcePackInfo makePackInfo(String name, boolean isAlwaysEnabled, Supplier<IResourcePack> resourceSupplier, IResourcePack resourcePack, PackMetadataSection resourcePackMeta, ResourcePackInfo.Priority priority, IPackNameDecorator decorator) {
+        int i = resourcePackMeta.getPackFormat();
+        Supplier<IResourcePack> supplier = resourceSupplier;
+
+        if (i <= 3) {
+            supplier = wrapV3(resourceSupplier);
+        }
+
+        if (i <= 4) {
+            supplier = wrapV4(supplier);
+        }
+        //Forge
+        if (Reflector.IForgeIResourcePack_isHidden.exists())
+            return (ResourcePackInfo) Reflector.newInstance(Reflector.ClientResourcePackInfo_Constructor, name, isAlwaysEnabled, supplier, resourcePack, resourcePackMeta, priority, decorator, Reflector.callBoolean(resourcePack, Reflector.IForgeIResourcePack_isHidden));
+        else
+            return new ResourcePackInfo(name, isAlwaysEnabled, supplier, resourcePack, resourcePackMeta, priority, decorator);
+        //
+    }
+
+    private static Supplier<IResourcePack> wrapV3(Supplier<IResourcePack> resourcePackSupplier) {
+        return () ->
+                new LegacyResourcePackWrapper(resourcePackSupplier.get(), LegacyResourcePackWrapper.NEW_TO_LEGACY_MAP);
+    }
+
+    private static Supplier<IResourcePack> wrapV4(Supplier<IResourcePack> resourcePackSupplier) {
+        return () ->
+                new LegacyResourcePackWrapperV4(resourcePackSupplier.get());
+    }
+
+    private static void sleepNanos(long nanoDelay) {
+        final long end = System.nanoTime() + nanoDelay;
+        do {
+            Thread.yield(); // This is a busy wait sadly...
+        } while (System.nanoTime() < end);
+    }
+
+    public void setDefaultMinecraftTitle() {
+        this.mainWindow.setWindowTitle(this.getWindowTitle());
+    }
+
+    private String getWindowTitle() {
+//Vivecraft
+        StringBuilder stringbuilder = new StringBuilder(minecriftVerString);
+//
+//        if (this.isModdedClient())
+//        {
+//            stringbuilder.append("*");
+//        }
+//
+        stringbuilder.append(" ");
+        stringbuilder.append(SharedConstants.getVersion().getName());
+        ClientPlayNetHandler clientplaynethandler = this.getConnection();
+
+        if (clientplaynethandler != null && clientplaynethandler.getNetworkManager().isChannelOpen()) {
+            stringbuilder.append(" - ");
+
+            if (this.integratedServer != null && !this.integratedServer.getPublic()) {
+                stringbuilder.append(I18n.format("title.singleplayer"));
+            } else if (this.isConnectedToRealms()) {
+                stringbuilder.append(I18n.format("title.multiplayer.realms"));
+            } else if (this.integratedServer == null && (this.currentServerData == null || !this.currentServerData.isOnLAN())) {
+                stringbuilder.append(I18n.format("title.multiplayer.other"));
+            } else {
+                stringbuilder.append(I18n.format("title.multiplayer.lan"));
+            }
+        }
+
+        return stringbuilder.toString();
+    }
+
+    private SocialInteractionsService func_244735_a(YggdrasilAuthenticationService p_244735_1_, GameConfiguration p_244735_2_) {
+        try {
+            return p_244735_1_.createSocialInteractionsService(p_244735_2_.userInfo.session.getToken());
+        } catch (AuthenticationException authenticationexception) {
+            LOGGER.error("Failed to verify authentication", authenticationexception);
+            return new OfflineSocialInteractions();
+        }
+    }
+
+    public boolean isModdedClient() {
+        return !"vanilla".equals(ClientBrandRetriever.getClientModName()) || Minecraft.class.getSigners() == null;
+    }
+
+    private void restoreResourcePacks(Throwable throwableIn) {
+        //Forge: This caused infinite loop if any resource packs are forced. Such as mod resources. So check if we can disable any.
+        if (this.resourcePackRepository.getEnabledPacks().stream().anyMatch(e -> !e.isAlwaysEnabled())) {
+            ITextComponent itextcomponent;
+
+            if (throwableIn instanceof SimpleReloadableResourceManager.FailedPackException) {
+                itextcomponent = new StringTextComponent(((SimpleReloadableResourceManager.FailedPackException) throwableIn).getPack().getName());
+            } else {
+                itextcomponent = null;
+            }
+
+            this.throwResourcePackLoadError(throwableIn, itextcomponent);
+        } else {
+            Util.toRuntimeException(throwableIn);
+        }
+    }
+
+    public void throwResourcePackLoadError(Throwable throwable, @Nullable ITextComponent errorMessage) {
+        LOGGER.info("Caught error loading resourcepacks, removing all selected resourcepacks", throwable);
+        this.resourcePackRepository.setEnabledPacks(Collections.emptyList());
+        this.gameSettings.resourcePacks.clear();
+        this.gameSettings.incompatibleResourcePacks.clear();
+        this.gameSettings.saveOptions();
+        this.reloadResources().thenRun(() ->
+        {
+            ToastGui toastgui = this.getToastGui();
+            SystemToast.addOrUpdate(toastgui, SystemToast.Type.PACK_LOAD_FAILURE, new TranslationTextComponent("resourcePack.load_fail"), errorMessage);
+        });
+    }
+
+    public void run() {
+        this.thread = Thread.currentThread();
+
+        try {
+            boolean flag = false;
+
+            while (this.running) {
+                if (this.crashReporter != null) {
                     displayCrashReport(this.crashReporter);
                     return;
                 }
 
-                try
-                {
+                try {
                     LongTickDetector longtickdetector = LongTickDetector.func_233524_a_("Renderer");
                     boolean flag1 = this.isDebugMode();
                     this.tick(flag1, longtickdetector);
@@ -666,31 +867,24 @@
                     this.runGameLoop(!flag);
                     this.profiler.endTick();
                     this.func_238210_b_(flag1, longtickdetector);
-                }
-                catch (OutOfMemoryError outofmemoryerror)
-                {
-                    if (flag)
-                    {
+                } catch (OutOfMemoryError outofmemoryerror) {
+                    if (flag) {
                         throw outofmemoryerror;
                     }
 
                     this.freeMemory();
                     this.displayGuiScreen(new MemoryErrorScreen());
                     System.gc();
-                    LOGGER.fatal("Out of memory", (Throwable)outofmemoryerror);
+                    LOGGER.fatal("Out of memory", outofmemoryerror);
                     flag = true;
                 }
             }
-        }
-        catch (ReportedException reportedexception)
-        {
+        } catch (ReportedException reportedexception) {
             this.addGraphicsAndWorldToCrashReport(reportedexception.getCrashReport());
             this.freeMemory();
-            LOGGER.fatal("Reported exception thrown!", (Throwable)reportedexception);
+            LOGGER.fatal("Reported exception thrown!", reportedexception);
             displayCrashReport(reportedexception.getCrashReport());
-        }
-        catch (Throwable throwable)
-        {
+        } catch (Throwable throwable) {
             CrashReport crashreport = this.addGraphicsAndWorldToCrashReport(new CrashReport("Unexpected error", throwable));
             LOGGER.fatal("Unreported exception thrown!", throwable);
             this.freeMemory();
@@ -698,35 +892,29 @@
         }
     }
 
-    void forceUnicodeFont(boolean forced)
-    {
+    void forceUnicodeFont(boolean forced) {
         this.fontResourceMananger.func_238551_a_(forced ? ImmutableMap.of(DEFAULT_FONT_RENDERER_NAME, UNIFORM_FONT_RENDERER_NAME) : ImmutableMap.of());
     }
 
     /**
      * Fills {@link #searchTreeManager} with the current item and recipe registry contents.
      */
-    private void populateSearchTreeManager()
-    {
+    private void populateSearchTreeManager() {
         SearchTree<ItemStack> searchtree = new SearchTree<>((stack) ->
-        {
-            return stack.getTooltip((PlayerEntity)null, ITooltipFlag.TooltipFlags.NORMAL).stream().map((textComponent) -> {
-                return TextFormatting.getTextWithoutFormattingCodes(textComponent.getString()).trim();
-            }).filter((name) -> {
-                return !name.isEmpty();
-            });
-        }, (stack) ->
-        {
-            return Stream.of(Registry.ITEM.getKey(stack.getItem()));
-        });
+                stack.getTooltip(null, ITooltipFlag.TooltipFlags.NORMAL).stream().map((textComponent) -> TextFormatting.getTextWithoutFormattingCodes(textComponent.getString()).trim()).filter((name) -> !name.isEmpty()), (stack) ->
+                Stream.of(Registry.ITEM.getKey(stack.getItem())));
         SearchTreeReloadable<ItemStack> searchtreereloadable = new SearchTreeReloadable<>((stack) ->
         {
-            return ItemTags.getCollection().getOwningTags(stack.getItem()).stream();
+            //Forge
+            if (Reflector.ForgeItem_getTags.exists())
+                return ((java.util.Set) Reflector.call(stack.getItem(), Reflector.ForgeItem_getTags)).stream();
+            else
+                return ItemTags.getCollection().getOwningTags(stack.getItem()).stream();
+            //
         });
         NonNullList<ItemStack> nonnulllist = NonNullList.create();
 
-        for (Item item : Registry.ITEM)
-        {
+        for (Item item : Registry.ITEM) {
             item.fillItemGroup(ItemGroup.SEARCH, nonnulllist);
         }
 
@@ -736,50 +924,19 @@
             searchtreereloadable.func_217872_a(stack);
         });
         SearchTree<RecipeList> searchtree1 = new SearchTree<>((recipeList) ->
-        {
-            return recipeList.getRecipes().stream().flatMap((recipe) -> {
-                return recipe.getRecipeOutput().getTooltip((PlayerEntity)null, ITooltipFlag.TooltipFlags.NORMAL).stream();
-            }).map((textComponent) -> {
-                return TextFormatting.getTextWithoutFormattingCodes(textComponent.getString()).trim();
-            }).filter((name) -> {
-                return !name.isEmpty();
-            });
-        }, (recipeList) ->
-        {
-            return recipeList.getRecipes().stream().map((recipe) -> {
-                return Registry.ITEM.getKey(recipe.getRecipeOutput().getItem());
-            });
-        });
+                recipeList.getRecipes().stream().flatMap((recipe) -> recipe.getRecipeOutput().getTooltip(null, ITooltipFlag.TooltipFlags.NORMAL).stream()).map((textComponent) -> TextFormatting.getTextWithoutFormattingCodes(textComponent.getString()).trim()).filter((name) -> !name.isEmpty()), (recipeList) ->
+                recipeList.getRecipes().stream().map((recipe) -> Registry.ITEM.getKey(recipe.getRecipeOutput().getItem())));
         this.searchTreeManager.add(SearchTreeManager.ITEMS, searchtree);
         this.searchTreeManager.add(SearchTreeManager.TAGS, searchtreereloadable);
         this.searchTreeManager.add(SearchTreeManager.RECIPES, searchtree1);
     }
 
-    private void disableVSyncAfterGlError(int error, long description)
-    {
+    private void disableVSyncAfterGlError(int error, long description) {
         this.gameSettings.vsync = false;
         this.gameSettings.saveOptions();
     }
 
-    private static boolean isJvm64bit()
-    {
-        String[] astring = new String[] {"sun.arch.data.model", "com.ibm.vm.bitmode", "os.arch"};
-
-        for (String s : astring)
-        {
-            String s1 = System.getProperty(s);
-
-            if (s1 != null && s1.contains("64"))
-            {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    public Framebuffer getFramebuffer()
-    {
+    public Framebuffer getFramebuffer() {
         return this.framebuffer;
     }
 
@@ -787,8 +944,7 @@
      * Gets the version that Minecraft was launched under (the name of a version JSON). Specified via the
      * <code>--version</code> flag.
      */
-    public String getVersion()
-    {
+    public String getVersion() {
         return this.launchedVersion;
     }
 
@@ -796,95 +952,64 @@
      * Gets the type of version that Minecraft was launched under (as specified in the version JSON). Specified via the
      * <code>--versionType</code> flag.
      */
-    public String getVersionType()
-    {
+    public String getVersionType() {
         return this.versionType;
     }
 
-    public void crashed(CrashReport crash)
-    {
+    public void crashed(CrashReport crash) {
         this.crashReporter = crash;
     }
 
-    /**
-     * Wrapper around displayCrashReportInternal
-     */
-    public static void displayCrashReport(CrashReport report)
-    {
-        File file1 = new File(getInstance().gameDir, "crash-reports");
-        File file2 = new File(file1, "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-client.txt");
-        Bootstrap.printToSYSOUT(report.getCompleteReport());
-
-        if (report.getFile() != null)
-        {
-            Bootstrap.printToSYSOUT("#@!@# Game crashed! Crash report saved to: #@!@# " + report.getFile());
-            System.exit(-1);
-        }
-        else if (report.saveToFile(file2))
-        {
-            Bootstrap.printToSYSOUT("#@!@# Game crashed! Crash report saved to: #@!@# " + file2.getAbsolutePath());
-            System.exit(-1);
-        }
-        else
-        {
-            Bootstrap.printToSYSOUT("#@?@# Game crashed! Crash report could not be saved. #@?@#");
-            System.exit(-2);
-        }
-    }
-
-    public boolean getForceUnicodeFont()
-    {
+    public boolean getForceUnicodeFont() {
         return this.gameSettings.forceUnicodeFont;
     }
 
-    public CompletableFuture<Void> reloadResources()
-    {
-        if (this.futureRefreshResources != null)
-        {
+    public CompletableFuture<Void> reloadResources() {
+        if (this.futureRefreshResources != null) {
             return this.futureRefreshResources;
-        }
-        else
-        {
+        } else {
             CompletableFuture<Void> completablefuture = new CompletableFuture<>();
 
-            if (this.loadingGui instanceof ResourceLoadProgressGui)
-            {
+            if (this.loadingGui instanceof ResourceLoadProgressGui) {
                 this.futureRefreshResources = completablefuture;
-                return completablefuture;
-            }
-            else
-            {
+            } else {
                 this.resourcePackRepository.reloadPacksFromFinders();
                 List<IResourcePack> list = this.resourcePackRepository.func_232623_f_();
                 this.setLoadingGui(new ResourceLoadProgressGui(this, this.resourceManager.reloadResources(Util.getServerExecutor(), this, RESOURCE_RELOAD_INIT_TASK, list), (throwable) ->
                 {
+                    //VIVECRAFT
+                    if (menuWorldRenderer.isReady() && resourcePacksChanged) {
+                        try {
+                            menuWorldRenderer.destroy();
+                            menuWorldRenderer.prepare();
+                        } catch (Exception e) {
+                            e.printStackTrace();
+                        }
+                    }
+                    resourcePacksChanged = false;
+                    //
                     Util.acceptOrElse(throwable, this::restoreResourcePacks, () -> {
                         this.worldRenderer.loadRenderers();
-                        completablefuture.complete((Void)null);
+                        completablefuture.complete(null);
                     });
                 }, true));
-                return completablefuture;
             }
+            return completablefuture;
         }
     }
 
-    private void checkMissingData()
-    {
+    private void checkMissingData() {
         boolean flag = false;
         BlockModelShapes blockmodelshapes = this.getBlockRendererDispatcher().getBlockModelShapes();
         IBakedModel ibakedmodel = blockmodelshapes.getModelManager().getMissingModel();
 
-        for (Block block : Registry.BLOCK)
-        {
-            for (BlockState blockstate : block.getStateContainer().getValidStates())
-            {
-                if (blockstate.getRenderType() == BlockRenderType.MODEL)
-                {
+        for (Block block : Registry.BLOCK) {
+            for (BlockState blockstate : block.getStateContainer().getValidStates()) {
+                if (blockstate.getRenderType() == BlockRenderType.MODEL) {
                     IBakedModel ibakedmodel1 = blockmodelshapes.getModel(blockstate);
 
-                    if (ibakedmodel1 == ibakedmodel)
-                    {
-                        LOGGER.debug("Missing model for: {}", (Object)blockstate);
+                    if (ibakedmodel1 == ibakedmodel) {
+                        LOGGER.debug("Missing model for: {}", blockstate);
                         flag = true;
                     }
                 }
@@ -893,15 +1018,12 @@
 
         TextureAtlasSprite textureatlassprite1 = ibakedmodel.getParticleTexture();
 
-        for (Block block1 : Registry.BLOCK)
-        {
-            for (BlockState blockstate1 : block1.getStateContainer().getValidStates())
-            {
+        for (Block block1 : Registry.BLOCK) {
+            for (BlockState blockstate1 : block1.getStateContainer().getValidStates()) {
                 TextureAtlasSprite textureatlassprite = blockmodelshapes.getTexture(blockstate1);
 
-                if (!blockstate1.isAir() && textureatlassprite == textureatlassprite1)
-                {
-                    LOGGER.debug("Missing particle icon for: {}", (Object)blockstate1);
+                if (!blockstate1.isAir() && textureatlassprite == textureatlassprite1) {
+                    LOGGER.debug("Missing particle icon for: {}", blockstate1);
                     flag = true;
                 }
             }
@@ -909,18 +1031,15 @@
 
         NonNullList<ItemStack> nonnulllist = NonNullList.create();
 
-        for (Item item : Registry.ITEM)
-        {
+        for (Item item : Registry.ITEM) {
             nonnulllist.clear();
             item.fillItemGroup(ItemGroup.SEARCH, nonnulllist);
 
-            for (ItemStack itemstack : nonnulllist)
-            {
+            for (ItemStack itemstack : nonnulllist) {
                 String s = itemstack.getTranslationKey();
                 String s1 = (new TranslationTextComponent(s)).getString();
 
-                if (s1.toLowerCase(Locale.ROOT).equals(item.getTranslationKey()))
-                {
+                if (s1.toLowerCase(Locale.ROOT).equals(item.getTranslationKey())) {
                     LOGGER.debug("Missing translation for: {} {} {}", itemstack, s, itemstack.getItem());
                 }
             }
@@ -928,8 +1047,7 @@
 
         flag = flag | ScreenManager.isMissingScreen();
 
-        if (flag)
-        {
+        if (flag) {
             throw new IllegalStateException("Your game data is foobar, fix the errors above!");
         }
     }
@@ -937,67 +1055,64 @@
     /**
      * Returns the save loader that is currently being used
      */
-    public SaveFormat getSaveLoader()
-    {
+    public SaveFormat getSaveLoader() {
         return this.saveFormat;
     }
 
-    private void openChatScreen(String defaultText)
-    {
-        if (!this.isIntegratedServerRunning() && !this.isChatEnabled())
-        {
-            if (this.player != null)
-            {
+    private void openChatScreen(String defaultText) {
+        if (!this.isIntegratedServerRunning() && !this.isChatEnabled()) {
+            if (this.player != null) {
                 this.player.sendMessage((new TranslationTextComponent("chat.cannotSend")).mergeStyle(TextFormatting.RED), Util.DUMMY_UUID);
             }
-        }
-        else
-        {
+        } else {
             this.displayGuiScreen(new ChatScreen(defaultText));
         }
     }
 
-    public void displayGuiScreen(@Nullable Screen guiScreenIn)
-    {
-        if (this.currentScreen != null)
-        {
-            this.currentScreen.onClose();
-        }
+    public void displayGuiScreen(@Nullable Screen guiScreenIn) {
+        //Forge
+        //if (this.currentScreen != null)
+        //{
+        //    this.currentScreen.onClose();
+        //}
 
-        if (guiScreenIn == null && this.world == null)
-        {
+        if (guiScreenIn == null && this.world == null) {
             guiScreenIn = new MainMenuScreen();
-        }
-        else if (guiScreenIn == null && this.player.getShouldBeDead())
-        {
-            if (this.player.isShowDeathScreen())
-            {
-                guiScreenIn = new DeathScreen((ITextComponent)null, this.world.getWorldInfo().isHardcore());
-            }
-            else
-            {
+        } else if (guiScreenIn == null && this.player.getShouldBeDead()) {
+            if (this.player.isShowDeathScreen()) {
+                guiScreenIn = new DeathScreen(null, this.world.getWorldInfo().isHardcore());
+            } else {
                 this.player.respawnPlayer();
             }
         }
-
-        if (guiScreenIn instanceof MainMenuScreen || guiScreenIn instanceof MultiplayerScreen)
-        {
+        //Forge
+        Screen old = this.currentScreen;
+        Object event = Reflector.newInstance(Reflector.GuiOpenEvent_Constructor, guiScreenIn);
+        if (event != null) {
+            if (Reflector.postForgeBusEvent(event)) return;
+            guiScreenIn = (Screen) Reflector.call(event, Reflector.GuiOpenEvent_getGui);
+        }
+        if (old != null && guiScreenIn != old)
+            old.onClose();
+        //
+        if (guiScreenIn instanceof MainMenuScreen || guiScreenIn instanceof MultiplayerScreen) {
             this.gameSettings.showDebugInfo = false;
             this.ingameGUI.getChatGUI().clearChatMessages(true);
         }
 
+        // VIVECRAFT
+        GuiHandler.onScreenChanged(this.currentScreen, guiScreenIn, true);
+        // VIVECRAFT
+
         this.currentScreen = guiScreenIn;
 
-        if (guiScreenIn != null)
-        {
+        if (guiScreenIn != null) {
             this.mouseHelper.ungrabMouse();
             KeyBinding.unPressAllKeys();
             guiScreenIn.init(this, this.mainWindow.getScaledWidth(), this.mainWindow.getScaledHeight());
             this.skipRenderWorld = false;
             NarratorChatListener.INSTANCE.say(guiScreenIn.getNarrationMessage());
-        }
-        else
-        {
+        } else {
             this.soundHandler.resume();
             this.mouseHelper.grabMouse();
         }
@@ -1005,64 +1120,50 @@
         this.setDefaultMinecraftTitle();
     }
 
-    public void setLoadingGui(@Nullable LoadingGui loadingGuiIn)
-    {
-        this.loadingGui = loadingGuiIn;
-    }
-
     /**
      * Shuts down the minecraft applet by stopping the resource downloads, and clearing up GL stuff; called when the
      * application (or web page) is exited.
      */
-    public void shutdownMinecraftApplet()
-    {
-        try
-        {
+    public void shutdownMinecraftApplet() {
+        try {
             LOGGER.info("Stopping!");
 
-            try
-            {
+            try {
                 NarratorChatListener.INSTANCE.close();
-            }
-            catch (Throwable throwable1)
-            {
+            } catch (Throwable ignored) {
             }
 
-            try
-            {
-                if (this.world != null)
-                {
+            try {
+                if (this.world != null) {
                     this.world.sendQuittingDisconnectingPacket();
                 }
 
                 this.unloadWorld();
-            }
-            catch (Throwable throwable)
-            {
+            } catch (Throwable ignored) {
             }
 
-            if (this.currentScreen != null)
-            {
+            if (this.currentScreen != null) {
                 this.currentScreen.onClose();
             }
 
             this.close();
-        }
-        finally
-        {
+        } finally {
             Util.nanoTimeSupplier = System::nanoTime;
+            // Vivecraft
+            try {
+                MCOpenVR.destroy();
+            } catch (Exception ignored) {
+            }
+            //
 
-            if (this.crashReporter == null)
-            {
+            if (this.crashReporter == null) {
                 System.exit(0);
             }
         }
     }
 
-    public void close()
-    {
-        try
-        {
+    public void close() {
+        try {
             this.modelManager.close();
             this.fontResourceMananger.close();
             this.gameRenderer.close();
@@ -1075,124 +1176,294 @@
             this.textureManager.close();
             this.resourceManager.close();
             Util.shutdown();
-        }
-        catch (Throwable throwable)
-        {
+        } catch (Throwable throwable) {
             LOGGER.error("Shutdown failure!", throwable);
             throw throwable;
-        }
-        finally
-        {
+        } finally {
             this.virtualScreen.close();
             this.mainWindow.close();
         }
     }
 
-    private void runGameLoop(boolean renderWorldIn)
-    {
+    private void runGameLoop(boolean renderWorldIn) {
         this.mainWindow.setRenderPhase("Pre render");
         long i = Util.nanoTime();
 
-        if (this.mainWindow.shouldClose())
-        {
+        if (this.mainWindow.shouldClose()) {
             this.shutdown();
         }
 
-        if (this.futureRefreshResources != null && !(this.loadingGui instanceof ResourceLoadProgressGui))
-        {
+        if (this.futureRefreshResources != null && !(this.loadingGui instanceof ResourceLoadProgressGui)) {
             CompletableFuture<Void> completablefuture = this.futureRefreshResources;
             this.futureRefreshResources = null;
             this.reloadResources().thenRun(() ->
-            {
-                completablefuture.complete((Void)null);
-            });
+                    completablefuture.complete(null));
         }
 
         Runnable runnable;
 
-        while ((runnable = this.queueChunkTracking.poll()) != null)
-        {
+        while ((runnable = this.queueChunkTracking.poll()) != null) {
             runnable.run();
         }
 
-        if (renderWorldIn)
-        {
+        if (renderWorldIn) {
+            // VIVECRAFT
+            this.frameDelta = (i - this.prevFrameTime) / 1000000000F;
+            this.prevFrameTime = i;
+            // avoid having to change GLX
+            gameSettings.ofFastRender = false;
+            this.frameIndex++;
+
             int j = this.timer.getPartialTicks(Util.milliTime());
             this.profiler.startSection("scheduledExecutables");
             this.drainTasks();
             this.profiler.endSection();
+
+            /** MINECRIFT setup the display, render buffers, shaders etc. */
+            try {
+                stereoProvider.setupRenderConfiguration();
+            } catch (RenderConfigException e) {
+                this.currentScreen = null;
+                GlStateManager.viewport(0, 0, mainWindow.getWidth(), mainWindow.getHeight());
+                if (loadingGui != null) {
+                    RenderSystem.clear(256, Minecraft.IS_RUNNING_ON_MAC);
+                    RenderSystem.matrixMode(5889);
+                    RenderSystem.loadIdentity();
+                    RenderSystem.ortho(0.0D, (double) mainWindow.getWidth() / mainWindow.getGuiScaleFactor(), (double) mainWindow.getHeight() / mainWindow.getGuiScaleFactor(), 0.0D, 1000.0D, 3000.0D);
+                    RenderSystem.matrixMode(5888);
+                    RenderSystem.loadIdentity();
+                    RenderSystem.translatef(0.0F, 0.0F, -2000.0F);
+                    RenderHelper.setupGui3DDiffuseLighting();
+                    loadingGui.render(new MatrixStack(), 0, 0, 0);
+                } else {
+                    notifyMirror(LangHelper.get("vivecraft.messages.rendersetupfailed", e.error), true, 10000);
+                    drawNotifyMirror();
+                    if (this.frameIndex % 300 == 0)
+                        System.out.println(e.title + " " + e.error);
+                    try {
+                        Thread.sleep(10);
+                    } catch (InterruptedException ignored) {
+                    }
+                }
+                mainWindow.flipFrame();
+                return;
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+            /** END MINECRIFT */
+
+            // Poll sensors
+            this.profiler.startSection("VR Poll/VSync");
+            MCOpenVR.poll(frameIndex);
+            this.profiler.endSection();
+            vrPlayer.postPoll();
+            //
+
             this.profiler.startSection("tick");
 
-            for (int k = 0; k < Math.min(10, j); ++k)
-            {
+            for (int k = 0; k < Math.min(10, j); ++k) {
                 this.profiler.func_230035_c_("clientTick");
+                // VIVECRAFT
+                vrPlayer.preTick();
+                //
                 this.runTick();
+                // VIVECRAFT
+                vrPlayer.postTick();
+                //
+                this.profiler.endSection();
             }
-
-            this.profiler.endSection();
         }
 
+        // avoid having to change GLX
+        gameSettings.ofFastRender = false;
+
+        this.profiler.endStartSection("setupRenderConfiguration");
         this.mouseHelper.updatePlayerLook();
         this.mainWindow.setRenderPhase("Render");
-        this.profiler.startSection("sound");
-        this.soundHandler.updateListener(this.gameRenderer.getActiveRenderInfo());
-        this.profiler.endSection();
-        this.profiler.startSection("render");
+
+        // VIVECRAFT - Check again in case something changed during Tick.
+        try {
+            checkGLError("pre render setup ");
+            stereoProvider.setupRenderConfiguration();
+            checkGLError("post render setup ");
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        // 1
+
+        // Vivecraft
+        float par1 = this.isGamePaused ? this.renderPartialTicksPaused : this.timer.renderPartialTicks;
+
+        this.profiler.endStartSection("preRender");
+        vrPlayer.preRender(par1);
+
+    	/* Vivecraft
         RenderSystem.pushMatrix();
         RenderSystem.clear(16640, IS_RUNNING_ON_MAC);
         this.framebuffer.bindFramebuffer(true);
+	        this.profiler.startSection("display");
+	        this.profiler.endSection();
+    	 */
         FogRenderer.resetFog();
-        this.profiler.startSection("display");
         RenderSystem.enableTexture();
-        RenderSystem.enableCull();
         this.profiler.endSection();
 
-        if (!this.skipRenderWorld)
-        {
-            this.profiler.endStartSection("gameRenderer");
-            this.gameRenderer.updateCameraAndRender(this.isGamePaused ? this.renderPartialTicksPaused : this.timer.renderPartialTicks, i, renderWorldIn);
-            this.profiler.endStartSection("toasts");
-            this.toastGui.func_238541_a_(new MatrixStack());
-            this.profiler.endSection();
-        }
+        this.profiler.startSection("Gui");
+        this.currentPass = RenderPass.GUI;
 
-        if (this.profilerResult != null)
-        {
-            this.profiler.startSection("fpsPie");
-            this.func_238183_a_(new MatrixStack(), this.profilerResult);
-            this.profiler.endSection();
+        //in case something needs it.
+        this.gameRenderer.getActiveRenderInfo().update(this.world, this.getRenderViewEntity(), false, false, par1);
+
+        //Forge - sure why not here?
+        if (!this.skipRenderWorld) {
+            Reflector.call(Reflector.BasicEventHooks_onRenderTickStart, par1);
         }
+        //
 
-        this.profiler.startSection("blit");
-        this.framebuffer.unbindFramebuffer();
-        RenderSystem.popMatrix();
-        RenderSystem.pushMatrix();
-        this.framebuffer.framebufferRender(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
-        RenderSystem.popMatrix();
-        this.profiler.endStartSection("updateDisplay");
-        this.mainWindow.flipFrame();
-        int i1 = this.getFramerateLimit();
+        GlStateManager.depthMask(true);
+        GlStateManager.colorMask(true, true, true, true);
 
-        if ((double)i1 < AbstractOption.FRAMERATE_LIMIT.getMaxValue())
-        {
-            RenderSystem.limitDisplayFPS(i1);
+        // Render GUI to FBO if necessary
+        this.framebuffer = GuiHandler.guiFramebuffer; // draw to 2d gui.
+        this.framebuffer.bindFramebuffer(true);
+
+        this.gameRenderer.drawFramebufferNEW(par1, renderWorldIn, new MatrixStack());
+
+        if (KeyboardHandler.Showing && !this.vrSettings.physicalKeyboard) {
+            this.framebuffer = KeyboardHandler.Framebuffer;
+            this.framebuffer.bindFramebuffer(true);
+            this.gameRenderer.drawScreen(par1, KeyboardHandler.UI, new MatrixStack());
+        }
+
+        if (RadialHandler.isShowing()) {
+            this.framebuffer = RadialHandler.Framebuffer;
+            this.framebuffer.bindFramebuffer(true);
+            this.gameRenderer.drawScreen(par1, RadialHandler.UI, new MatrixStack());
+        }
+
+        checkGLError("post 2d ");
+        VRHotkeys.updateMovingThirdPersonCam();
+        //
+        this.profiler.endStartSection("sound");
+        this.currentPass = RenderPass.CENTER;
+        this.soundHandler.updateListener(gameRenderer.getActiveRenderInfo());
+        this.profiler.endSection();
+
+        this.profiler.startSection("render");
+
+        if (!this.skipRenderWorld) {
+            // VIVECRAFT RENDERING MAIN
+            if (minecriftDebug)
+                print("FrameIndex: " + frameIndex);
+
+            List<RenderPass> passes = this.stereoProvider.getRenderPasses();
+
+            /** Minecrift - main stereo render loop **/
+            for (RenderPass pass : passes) {
+                this.currentPass = pass;
+                switch (pass) {
+                    case LEFT:
+                    case RIGHT:
+                        this.framebuffer = stereoProvider.framebufferVrRender;
+                        break;
+                    case CENTER:
+                        this.framebuffer = stereoProvider.framebufferUndistorted;
+                        break;
+                    case THIRD:
+                        this.framebuffer = stereoProvider.framebufferMR;
+                        break;
+                    case SCOPEL:
+                        this.framebuffer = stereoProvider.telescopeFramebufferL;
+                        break;
+                    case SCOPER:
+                        this.framebuffer = stereoProvider.telescopeFramebufferR;
+                        break;
+                    case CAMERA:
+                        this.framebuffer = stereoProvider.cameraRenderFramebuffer;
+                        break;
+                }
+
+                this.profiler.startSection("Eye:" + currentPass.ordinal());
+                this.profiler.startSection("setup");
+                this.framebuffer.bindFramebuffer(true); // draw to main texture for every pass
+
+                this.profiler.endSection();
+                RenderSystem.loadIdentity();
+                renderSingleView(pass.ordinal(), par1, renderWorldIn);
+                this.profiler.endSection(); // eye
+
+                if (grabScreenShot) {
+                    boolean inPass;
+                    if (passes.contains(RenderPass.CAMERA)) {
+                        inPass = (pass == RenderPass.CAMERA);
+                    } else if (passes.contains(RenderPass.CENTER)) {
+                        inPass = (pass == RenderPass.CENTER);
+                    } else {
+                        inPass = vrSettings.displayMirrorLeftEye ? (pass == RenderPass.LEFT) : (pass == RenderPass.RIGHT);
+                    }
+
+                    if (inPass) {
+                        Framebuffer ssfb = this.framebuffer;
+                        if (pass == RenderPass.CAMERA)
+                            ssfb = stereoProvider.cameraFramebuffer;
+
+                        this.framebuffer.unbindFramebuffer();
+                        Utils.takeScreenshot(ssfb);
+                        this.mainWindow.flipFrame();
+
+                        grabScreenShot = false;
+                    }
+                }
+            } // end per eye rendering.
+
+
+            //VIVECRAFT
+            if (renderWorldIn) {
+                //
+                vrPlayer.postRender(par1);
+                //
+
+                profiler.startSection("Display/Reproject");
+                try {
+                    this.stereoProvider.endFrame();
+                } catch (Exception e) {
+                    LOGGER.error(e.toString());
+                }
+                profiler.endSection();
+
+                checkGLError("post submit ");
+            }
+            //
+
+            //Forge - sure why not here?
+            if (!this.skipRenderWorld) {
+                Reflector.call(Reflector.BasicEventHooks_onRenderTickEnd, par1);
+            }
+            //
+
+            this.profiler.startSection("mirror");
+            this.framebuffer.unbindFramebuffer(); // draw directly to window
+            copyToMirror();
+            drawNotifyMirror();
+            checkGLError("post-mirror ");
+            this.profiler.endSection();
+
+            //// END MAIN VIVECRAFT RENDERING
         }
 
-        this.profiler.endStartSection("yield");
-        Thread.yield();
+        this.getProfiler().endSection(); //render
+
         this.profiler.endSection();
         this.mainWindow.setRenderPhase("Post render");
+        this.mainWindow.flipFrame();
+
         ++this.fpsCounter;
         boolean flag = this.isSingleplayer() && (this.currentScreen != null && this.currentScreen.isPauseScreen() || this.loadingGui != null && this.loadingGui.isPauseScreen()) && !this.integratedServer.getPublic();
 
-        if (this.isGamePaused != flag)
-        {
-            if (this.isGamePaused)
-            {
+        if (this.isGamePaused != flag) {
+            if (this.isGamePaused) {
                 this.renderPartialTicksPaused = this.timer.renderPartialTicks;
-            }
-            else
-            {
+            } else {
                 this.timer.renderPartialTicks = this.renderPartialTicksPaused;
             }
 
@@ -1204,16 +1475,14 @@
         this.startNanoTime = l;
         this.profiler.startSection("fpsUpdate");
 
-        while (Util.milliTime() >= this.debugUpdateTime + 1000L)
-        {
+        while (Util.milliTime() >= this.debugUpdateTime + 1000L) {
             debugFPS = this.fpsCounter;
-            this.debug = String.format("%d fps T: %s%s%s%s B: %d", debugFPS, (double)this.gameSettings.framerateLimit == AbstractOption.FRAMERATE_LIMIT.getMaxValue() ? "inf" : this.gameSettings.framerateLimit, this.gameSettings.vsync ? " vsync" : "", this.gameSettings.graphicFanciness.toString(), this.gameSettings.cloudOption == CloudOption.OFF ? "" : (this.gameSettings.cloudOption == CloudOption.FAST ? " fast-clouds" : " fancy-clouds"), this.gameSettings.biomeBlendRadius);
+            this.debug = String.format("%d fps T: %s%s%s%s B: %d", debugFPS, (double) this.gameSettings.framerateLimit == AbstractOption.FRAMERATE_LIMIT.getMaxValue() ? "inf" : this.gameSettings.framerateLimit, this.gameSettings.vsync ? " vsync" : "", this.gameSettings.graphicFanciness.toString(), this.gameSettings.cloudOption == CloudOption.OFF ? "" : (this.gameSettings.cloudOption == CloudOption.FAST ? " fast-clouds" : " fancy-clouds"), this.gameSettings.biomeBlendRadius);
             this.debugUpdateTime += 1000L;
             this.fpsCounter = 0;
             this.snooper.addMemoryStatsToSnooper();
 
-            if (!this.snooper.isSnooperRunning())
-            {
+            if (!this.snooper.isSnooperRunning()) {
                 this.snooper.start();
             }
         }
@@ -1221,103 +1490,85 @@
         this.profiler.endSection();
     }
 
-    private boolean isDebugMode()
-    {
+    private boolean isDebugMode() {
         return this.gameSettings.showDebugInfo && this.gameSettings.showDebugProfilerChart && !this.gameSettings.hideGUI;
     }
 
-    private void tick(boolean isDebug, @Nullable LongTickDetector detector)
-    {
-        if (isDebug)
-        {
-            if (!this.gameTimeTracker.func_233505_a_())
-            {
+    private void tick(boolean isDebug, @Nullable LongTickDetector detector) {
+        if (isDebug) {
+            if (!this.gameTimeTracker.func_233505_a_()) {
                 this.gameTime = 0;
                 this.gameTimeTracker.func_233507_c_();
             }
 
             ++this.gameTime;
-        }
-        else
-        {
+        } else {
             this.gameTimeTracker.func_233506_b_();
         }
 
         this.profiler = LongTickDetector.func_233523_a_(this.gameTimeTracker.func_233508_d_(), detector);
     }
 
-    private void func_238210_b_(boolean isDebug, @Nullable LongTickDetector detector)
-    {
-        if (detector != null)
-        {
+    private void func_238210_b_(boolean isDebug, @Nullable LongTickDetector detector) {
+        if (detector != null) {
             detector.func_233525_b_();
         }
 
-        if (isDebug)
-        {
+        if (isDebug) {
             this.profilerResult = this.gameTimeTracker.func_233509_e_();
-        }
-        else
-        {
+        } else {
             this.profilerResult = null;
         }
 
         this.profiler = this.gameTimeTracker.func_233508_d_();
     }
 
-    public void updateWindowSize()
-    {
+    public void updateWindowSize() {
         int i = this.mainWindow.calcGuiScale(this.gameSettings.guiScale, this.getForceUnicodeFont());
-        this.mainWindow.setGuiScale((double)i);
+        this.mainWindow.setGuiScale(i);
 
-        if (this.currentScreen != null)
-        {
+        if (stereoProvider != null)
+            stereoProvider.reinitFrameBuffers("Main Window Changed");
+
+        if (this.currentScreen != null) {
             this.currentScreen.resize(this, this.mainWindow.getScaledWidth(), this.mainWindow.getScaledHeight());
         }
+        //Vivecraft do not do this.
+        //Framebuffer framebuffer = this.getFramebuffer();
+        //framebuffer.resize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight(), IS_RUNNING_ON_MAC);
+        //Forge adds nullcheck
+        //if (this.gameRenderer!=null) this.gameRenderer.updateShaderGroupSize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
 
-        Framebuffer framebuffer = this.getFramebuffer();
-        framebuffer.resize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight(), IS_RUNNING_ON_MAC);
-        this.gameRenderer.updateShaderGroupSize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
         this.mouseHelper.setIgnoreFirstMove();
     }
 
-    public void ignoreFirstMove()
-    {
+    public void ignoreFirstMove() {
         this.mouseHelper.ignoreFirstMove();
     }
 
-    private int getFramerateLimit()
-    {
+    private int getFramerateLimit() {
         return this.world != null || this.currentScreen == null && this.loadingGui == null ? this.mainWindow.getLimitFramerate() : 60;
     }
 
     /**
      * Attempts to free as much memory as possible, including leaving the world and running the garbage collector.
      */
-    public void freeMemory()
-    {
-        try
-        {
+    public void freeMemory() {
+        try {
             memoryReserve = new byte[0];
             this.worldRenderer.deleteAllDisplayLists();
-        }
-        catch (Throwable throwable1)
-        {
+        } catch (Throwable ignored) {
         }
 
-        try
-        {
+        try {
             System.gc();
 
-            if (this.integratedServerIsRunning && this.integratedServer != null)
-            {
+            if (this.integratedServerIsRunning && this.integratedServer != null) {
                 this.integratedServer.initiateShutdown(true);
             }
 
             this.unloadWorld(new DirtMessageScreen(new TranslationTextComponent("menu.savingLevel")));
-        }
-        catch (Throwable throwable)
-        {
+        } catch (Throwable ignored) {
         }
 
         System.gc();
@@ -1326,36 +1577,26 @@
     /**
      * Update debugProfilerName in response to number keys in debug screen
      */
-    void updateDebugProfilerName(int keyCount)
-    {
-        if (this.profilerResult != null)
-        {
+    void updateDebugProfilerName(int keyCount) {
+        if (this.profilerResult != null) {
             List<DataPoint> list = this.profilerResult.getDataPoints(this.debugProfilerName);
 
-            if (!list.isEmpty())
-            {
+            if (!list.isEmpty()) {
                 DataPoint datapoint = list.remove(0);
 
-                if (keyCount == 0)
-                {
-                    if (!datapoint.name.isEmpty())
-                    {
+                if (keyCount == 0) {
+                    if (!datapoint.name.isEmpty()) {
                         int i = this.debugProfilerName.lastIndexOf(30);
 
-                        if (i >= 0)
-                        {
+                        if (i >= 0) {
                             this.debugProfilerName = this.debugProfilerName.substring(0, i);
                         }
                     }
-                }
-                else
-                {
+                } else {
                     --keyCount;
 
-                    if (keyCount < list.size() && !"unspecified".equals((list.get(keyCount)).name))
-                    {
-                        if (!this.debugProfilerName.isEmpty())
-                        {
+                    if (keyCount < list.size() && !"unspecified".equals((list.get(keyCount)).name)) {
+                        if (!this.debugProfilerName.isEmpty()) {
                             this.debugProfilerName = this.debugProfilerName + '\u001e';
                         }
 
@@ -1366,14 +1607,21 @@
         }
     }
 
-    private void func_238183_a_(MatrixStack matrixStack, IProfileResult profilerResult)
-    {
+    public void drawProfiler() {
+        if (this.profilerResult != null) {
+            this.profiler.startSection("fpsPie");
+            this.func_238183_a_(new MatrixStack(), this.profilerResult);
+            this.profiler.endSection();
+        }
+    }
+
+    private void func_238183_a_(MatrixStack matrixStack, IProfileResult profilerResult) {
         List<DataPoint> list = profilerResult.getDataPoints(this.debugProfilerName);
         DataPoint datapoint = list.remove(0);
         RenderSystem.clear(256, IS_RUNNING_ON_MAC);
         RenderSystem.matrixMode(5889);
         RenderSystem.loadIdentity();
-        RenderSystem.ortho(0.0D, (double)this.mainWindow.getFramebufferWidth(), (double)this.mainWindow.getFramebufferHeight(), 0.0D, 1000.0D, 3000.0D);
+        RenderSystem.ortho(0.0D, this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight(), 0.0D, 1000.0D, 3000.0D);
         RenderSystem.matrixMode(5888);
         RenderSystem.loadIdentity();
         RenderSystem.translatef(0.0F, 0.0F, -2000.0F);
@@ -1382,49 +1630,46 @@
         Tessellator tessellator = Tessellator.getInstance();
         BufferBuilder bufferbuilder = tessellator.getBuffer();
         int i = 160;
-        int j = this.mainWindow.getFramebufferWidth() - 160 - 10;
-        int k = this.mainWindow.getFramebufferHeight() - 320;
+        int j = this.mainWindow.getFramebufferWidth() / 3;
+        int k = this.mainWindow.getFramebufferHeight() / 9;
         RenderSystem.enableBlend();
+        RenderSystem.scaled(2.2, 2.7, 1);
         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
-        bufferbuilder.pos((double)((float)j - 176.0F), (double)((float)k - 96.0F - 16.0F), 0.0D).color(200, 0, 0, 0).endVertex();
-        bufferbuilder.pos((double)((float)j - 176.0F), (double)(k + 320), 0.0D).color(200, 0, 0, 0).endVertex();
-        bufferbuilder.pos((double)((float)j + 176.0F), (double)(k + 320), 0.0D).color(200, 0, 0, 0).endVertex();
-        bufferbuilder.pos((double)((float)j + 176.0F), (double)((float)k - 96.0F - 16.0F), 0.0D).color(200, 0, 0, 0).endVertex();
+        bufferbuilder.pos((float) j - 176.0F, (float) k - 96.0F - 16.0F, 0.0D).color(200, 0, 0, 0).endVertex();
+        bufferbuilder.pos((float) j - 176.0F, k + 320, 0.0D).color(200, 0, 0, 0).endVertex();
+        bufferbuilder.pos((float) j + 176.0F, k + 320, 0.0D).color(200, 0, 0, 0).endVertex();
+        bufferbuilder.pos((float) j + 4 * 176.0F, (float) k - 96.0F - 16.0F, 0.0D).color(200, 0, 0, 0).endVertex();
         tessellator.draw();
         RenderSystem.disableBlend();
         double d0 = 0.0D;
 
-        for (DataPoint datapoint1 : list)
-        {
+        for (DataPoint datapoint1 : list) {
             int l = MathHelper.floor(datapoint1.relTime / 4.0D) + 1;
             bufferbuilder.begin(6, DefaultVertexFormats.POSITION_COLOR);
             int i1 = datapoint1.getTextColor();
             int j1 = i1 >> 16 & 255;
             int k1 = i1 >> 8 & 255;
             int l1 = i1 & 255;
-            bufferbuilder.pos((double)j, (double)k, 0.0D).color(j1, k1, l1, 255).endVertex();
+            bufferbuilder.pos(j, k, 0.0D).color(j1, k1, l1, 255).endVertex();
 
-            for (int i2 = l; i2 >= 0; --i2)
-            {
-                float f = (float)((d0 + datapoint1.relTime * (double)i2 / (double)l) * (double)((float)Math.PI * 2F) / 100.0D);
+            for (int i2 = l; i2 >= 0; --i2) {
+                float f = (float) ((d0 + datapoint1.relTime * (double) i2 / (double) l) * (double) ((float) Math.PI * 2F) / 100.0D);
                 float f1 = MathHelper.sin(f) * 160.0F;
                 float f2 = MathHelper.cos(f) * 160.0F * 0.5F;
-                bufferbuilder.pos((double)((float)j + f1), (double)((float)k - f2), 0.0D).color(j1, k1, l1, 255).endVertex();
+                bufferbuilder.pos((float) j + f1, (float) k - f2, 0.0D).color(j1, k1, l1, 255).endVertex();
             }
 
             tessellator.draw();
             bufferbuilder.begin(5, DefaultVertexFormats.POSITION_COLOR);
 
-            for (int l2 = l; l2 >= 0; --l2)
-            {
-                float f3 = (float)((d0 + datapoint1.relTime * (double)l2 / (double)l) * (double)((float)Math.PI * 2F) / 100.0D);
+            for (int l2 = l; l2 >= 0; --l2) {
+                float f3 = (float) ((d0 + datapoint1.relTime * (double) l2 / (double) l) * (double) ((float) Math.PI * 2F) / 100.0D);
                 float f4 = MathHelper.sin(f3) * 160.0F;
                 float f5 = MathHelper.cos(f3) * 160.0F * 0.5F;
 
-                if (!(f5 > 0.0F))
-                {
-                    bufferbuilder.pos((double)((float)j + f4), (double)((float)k - f5), 0.0D).color(j1 >> 1, k1 >> 1, l1 >> 1, 255).endVertex();
-                    bufferbuilder.pos((double)((float)j + f4), (double)((float)k - f5 + 10.0F), 0.0D).color(j1 >> 1, k1 >> 1, l1 >> 1, 255).endVertex();
+                if (!(f5 > 0.0F)) {
+                    bufferbuilder.pos((float) j + f4, (float) k - f5, 0.0D).color(j1 >> 1, k1 >> 1, l1 >> 1, 255).endVertex();
+                    bufferbuilder.pos((float) j + f4, (float) k - f5 + 10.0F, 0.0D).color(j1 >> 1, k1 >> 1, l1 >> 1, 255).endVertex();
                 }
             }
 
@@ -1438,155 +1683,156 @@
         String s = IProfileResult.decodePath(datapoint.name);
         String s1 = "";
 
-        if (!"unspecified".equals(s))
-        {
+        if (!"unspecified".equals(s)) {
             s1 = s1 + "[0] ";
         }
 
-        if (s.isEmpty())
-        {
+        if (s.isEmpty()) {
             s1 = s1 + "ROOT ";
-        }
-        else
-        {
+        } else {
             s1 = s1 + s + ' ';
         }
 
         int k2 = 16777215;
-        this.fontRenderer.drawStringWithShadow(matrixStack, s1, (float)(j - 160), (float)(k - 80 - 16), 16777215);
+        this.fontRenderer.drawStringWithShadow(matrixStack, s1, (float) (j - 160), (float) (k - 80 - 16), 16777215);
         s1 = decimalformat.format(datapoint.rootRelTime) + "%";
-        this.fontRenderer.drawStringWithShadow(matrixStack, s1, (float)(j + 160 - this.fontRenderer.getStringWidth(s1)), (float)(k - 80 - 16), 16777215);
+        this.fontRenderer.drawStringWithShadow(matrixStack, s1, (float) (j + 160 - this.fontRenderer.getStringWidth(s1)), (float) (k - 80 - 16), 16777215);
 
-        for (int j2 = 0; j2 < list.size(); ++j2)
-        {
+        for (int j2 = 0; j2 < list.size(); ++j2) {
             DataPoint datapoint2 = list.get(j2);
             StringBuilder stringbuilder = new StringBuilder();
 
-            if ("unspecified".equals(datapoint2.name))
-            {
+            if ("unspecified".equals(datapoint2.name)) {
                 stringbuilder.append("[?] ");
-            }
-            else
-            {
+            } else {
                 stringbuilder.append("[").append(j2 + 1).append("] ");
             }
 
             String s2 = stringbuilder.append(datapoint2.name).toString();
-            this.fontRenderer.drawStringWithShadow(matrixStack, s2, (float)(j - 160), (float)(k + 80 + j2 * 8 + 20), datapoint2.getTextColor());
+            this.fontRenderer.drawStringWithShadow(matrixStack, s2, (float) (j - 160), (float) (k + 80 + j2 * 8 + 20), datapoint2.getTextColor());
             s2 = decimalformat.format(datapoint2.relTime) + "%";
-            this.fontRenderer.drawStringWithShadow(matrixStack, s2, (float)(j + 160 - 50 - this.fontRenderer.getStringWidth(s2)), (float)(k + 80 + j2 * 8 + 20), datapoint2.getTextColor());
+            this.fontRenderer.drawStringWithShadow(matrixStack, s2, (float) (j + 160 - 50 - this.fontRenderer.getStringWidth(s2)), (float) (k + 80 + j2 * 8 + 20), datapoint2.getTextColor());
             s2 = decimalformat.format(datapoint2.rootRelTime) + "%";
-            this.fontRenderer.drawStringWithShadow(matrixStack, s2, (float)(j + 160 - this.fontRenderer.getStringWidth(s2)), (float)(k + 80 + j2 * 8 + 20), datapoint2.getTextColor());
+            this.fontRenderer.drawStringWithShadow(matrixStack, s2, (float) (j + 160 - this.fontRenderer.getStringWidth(s2)), (float) (k + 80 + j2 * 8 + 20), datapoint2.getTextColor());
         }
     }
 
     /**
      * Called when the window is closing. Sets 'running' to false which allows the game loop to exit cleanly.
      */
-    public void shutdown()
-    {
+    public void shutdown() {
         this.running = false;
     }
 
-    public boolean isRunning()
-    {
+    public boolean isRunning() {
         return this.running;
     }
 
     /**
      * Displays the ingame menu
      */
-    public void displayInGameMenu(boolean pauseOnly)
-    {
-        if (this.currentScreen == null)
-        {
+    public void displayInGameMenu(boolean pauseOnly) {
+        if (this.currentScreen == null) {
             boolean flag = this.isSingleplayer() && !this.integratedServer.getPublic();
 
-            if (flag)
-            {
+            if (flag) {
                 this.displayGuiScreen(new IngameMenuScreen(!pauseOnly));
                 this.soundHandler.pause();
-            }
-            else
-            {
+            } else {
                 this.displayGuiScreen(new IngameMenuScreen(true));
             }
         }
     }
 
-    private void sendClickBlockToController(boolean leftClick)
-    {
-        if (!leftClick)
-        {
+    private void sendClickBlockToController(boolean leftClick) {
+        if (!leftClick) {
             this.leftClickCounter = 0;
         }
 
-        if (this.leftClickCounter <= 0 && !this.player.isHandActive())
-        {
-            if (leftClick && this.objectMouseOver != null && this.objectMouseOver.getType() == RayTraceResult.Type.BLOCK)
-            {
-                BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult)this.objectMouseOver;
+        if (this.leftClickCounter <= 0 && !this.player.isHandActive()) {
+            if (leftClick && this.objectMouseOver != null && this.objectMouseOver.getType() == RayTraceResult.Type.BLOCK) {
+                BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult) this.objectMouseOver;
                 BlockPos blockpos = blockraytraceresult.getPos();
 
-                if (!this.world.getBlockState(blockpos).isAir())
-                {
+                Object inputEvent;
+                if (!this.world.isAirBlock(blockpos)) {
+                    //Forge
+                    inputEvent = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 0, this.gameSettings.keyBindAttack, Hand.MAIN_HAND);
+                    if (inputEvent != null && Reflector.callBoolean(inputEvent, Reflector.Event_isCanceled)) {
+                        if (Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand)) {
+                            this.particles.addBlockHitEffects(blockpos, blockraytraceresult);
+                            this.player.swingArm(Hand.MAIN_HAND, VRFirstPersonArmSwing.Attack);
+                        }
+                        return;
+                    }
+                    //
                     Direction direction = blockraytraceresult.getFace();
 
-                    if (this.playerController.onPlayerDamageBlock(blockpos, direction))
-                    {
-                        this.particles.addBlockHitEffects(blockpos, direction);
-                        this.player.swingArm(Hand.MAIN_HAND);
+                    if (this.playerController.onPlayerDamageBlock(blockpos, direction)) {
+                        //Forge
+                        if (inputEvent != null) {
+                            if (Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand)) {
+                                this.particles.addBlockHitEffects(blockpos, blockraytraceresult);
+                                this.player.swingArm(Hand.MAIN_HAND, VRFirstPersonArmSwing.Attack);
+                            }
+                        } else {
+                            this.particles.addBlockHitEffects(blockpos, direction);
+                            this.player.swingArm(Hand.MAIN_HAND, VRFirstPersonArmSwing.Attack);
+                        }
                     }
                 }
             }
-            else
+            //Vivecraft only if seated
+            else if (vrSettings.seated)
+            //
             {
                 this.playerController.resetBlockRemoving();
             }
         }
     }
 
-    private void clickMouse()
-    {
-        if (this.leftClickCounter <= 0)
-        {
-            if (this.objectMouseOver == null)
-            {
+    private void clickMouse() {
+        if (this.leftClickCounter <= 0) {
+            if (this.objectMouseOver == null) {
                 LOGGER.error("Null returned as 'hitResult', this shouldn't happen!");
 
-                if (this.playerController.isNotCreative())
-                {
+                if (this.playerController.isNotCreative()) {
                     this.leftClickCounter = 10;
                 }
-            }
-            else if (!this.player.isRowingBoat())
-            {
-                switch (this.objectMouseOver.getType())
-                {
-                    case ENTITY:
-                        this.playerController.attackEntity(this.player, ((EntityRayTraceResult)this.objectMouseOver).getEntity());
-                        break;
-
-                    case BLOCK:
-                        BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult)this.objectMouseOver;
-                        BlockPos blockpos = blockraytraceresult.getPos();
-
-                        if (!this.world.getBlockState(blockpos).isAir())
-                        {
-                            this.playerController.clickBlock(blockpos, blockraytraceresult.getFace());
+            } else if (!this.player.isRowingBoat()) {
+                Object inputEvent;
+                //Forge
+                inputEvent = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 0, this.gameSettings.keyBindAttack, Hand.MAIN_HAND);
+
+                if (inputEvent == null || !Reflector.callBoolean(inputEvent, Reflector.Event_isCanceled))
+                    //
+                    switch (this.objectMouseOver.getType()) {
+                        case ENTITY:
+                            this.playerController.attackEntity(this.player, ((EntityRayTraceResult) this.objectMouseOver).getEntity());
                             break;
-                        }
 
-                    case MISS:
-                        if (this.playerController.isNotCreative())
-                        {
-                            this.leftClickCounter = 10;
-                        }
+                        case BLOCK:
+                            BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult) this.objectMouseOver;
+                            BlockPos blockpos = blockraytraceresult.getPos();
 
-                        this.player.resetCooldown();
-                }
+                            if (!this.world.isAirBlock(blockpos)) {
+                                this.playerController.clickBlock(blockpos, blockraytraceresult.getFace());
+                                break;
+                            }
+
+                        case MISS:
+                            if (this.playerController.isNotCreative()) {
+                                this.leftClickCounter = 10;
+                            }
 
-                this.player.swingArm(Hand.MAIN_HAND);
+                            this.player.resetCooldown();
+                            //Forge
+                            Reflector.call(Reflector.ForgeHooks_onEmptyLeftClick, this.player);
+                            //
+                    }
+
+                if (inputEvent == null || Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand))
+                    this.player.swingArm(Hand.MAIN_HAND);
             }
         }
     }
@@ -1594,42 +1840,55 @@
     /**
      * Called when user clicked he's mouse right button (place)
      */
-    private void rightClickMouse()
-    {
-        if (!this.playerController.getIsHittingBlock())
-        {
+    public void rightClickMouse() {
+        //Vivecraft check seated
+        if (!this.playerController.getIsHittingBlock() || !vrSettings.seated) {
+            //
+            //Vivecraft delay
             this.rightClickDelayTimer = 4;
+            //
 
-            if (!this.player.isRowingBoat())
-            {
-                if (this.objectMouseOver == null)
-                {
+            if (!this.player.isRowingBoat()) {
+                if (this.objectMouseOver == null) {
                     LOGGER.warn("Null returned as 'hitResult', this shouldn't happen!");
                 }
 
-                for (Hand hand : Hand.values())
-                {
-                    ItemStack itemstack = this.player.getHeldItem(hand);
+                for (Hand hand : Hand.values()) {
+                    Object inputEvent;
+                    inputEvent = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 1, this.gameSettings.keyBindUseItem, hand);
+
+                    if (inputEvent != null && Reflector.callBoolean(inputEvent, Reflector.Event_isCanceled)) {
+                        if (Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand))
+                            this.player.swingArm(hand);
+                        return;
+                    }
 
-                    if (this.objectMouseOver != null)
-                    {
-                        switch (this.objectMouseOver.getType())
-                        {
+                    ItemStack itemstack = this.player.getHeldItem(hand);
+                    if (TelescopeTracker.isTelescope(itemstack))
+                        continue;
+                    //Vivecraft
+                    NetworkHelper.sendActiveHand((byte) hand.ordinal());
+                    //
+                    if (this.objectMouseOver != null) {
+                        switch (this.objectMouseOver.getType()) {
                             case ENTITY:
-                                EntityRayTraceResult entityraytraceresult = (EntityRayTraceResult)this.objectMouseOver;
+                                //ft where are you
+                                physicalGuiManager.preClickAction();
+                                //
+                                EntityRayTraceResult entityraytraceresult = (EntityRayTraceResult) this.objectMouseOver;
                                 Entity entity = entityraytraceresult.getEntity();
                                 ActionResultType actionresulttype = this.playerController.interactWithEntity(this.player, entity, entityraytraceresult, hand);
 
-                                if (!actionresulttype.isSuccessOrConsume())
-                                {
+                                if (!actionresulttype.isSuccessOrConsume()) {
                                     actionresulttype = this.playerController.interactWithEntity(this.player, entity, hand);
                                 }
 
-                                if (actionresulttype.isSuccessOrConsume())
-                                {
-                                    if (actionresulttype.isSuccess())
-                                    {
-                                        this.player.swingArm(hand);
+                                if (actionresulttype.isSuccessOrConsume()) {
+                                    if (actionresulttype.isSuccess()) {
+                                        //Vivecraft
+                                        if (inputEvent == null || Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand))
+                                            this.player.swingArm(hand, VRFirstPersonArmSwing.Use);
+                                        //
                                     }
 
                                     return;
@@ -1638,18 +1897,17 @@
                                 break;
 
                             case BLOCK:
-                                BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult)this.objectMouseOver;
+                                BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult) this.objectMouseOver;
                                 int i = itemstack.getCount();
                                 ActionResultType actionresulttype1 = this.playerController.func_217292_a(this.player, this.world, hand, blockraytraceresult);
 
-                                if (actionresulttype1.isSuccessOrConsume())
-                                {
-                                    if (actionresulttype1.isSuccess())
-                                    {
-                                        this.player.swingArm(hand);
-
-                                        if (!itemstack.isEmpty() && (itemstack.getCount() != i || this.playerController.isInCreativeMode()))
-                                        {
+                                if (actionresulttype1.isSuccessOrConsume()) {
+                                    if (actionresulttype1.isSuccess()) {
+                                        //Vivecraft
+                                        if (inputEvent == null || Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand))
+                                            this.player.swingArm(hand, VRFirstPersonArmSwing.Use);
+                                        //
+                                        if (!itemstack.isEmpty() && (itemstack.getCount() != i || this.playerController.isInCreativeMode())) {
                                             this.gameRenderer.itemRenderer.resetEquippedProgress(hand);
                                         }
                                     }
@@ -1657,22 +1915,27 @@
                                     return;
                                 }
 
-                                if (actionresulttype1 == ActionResultType.FAIL)
-                                {
+                                if (actionresulttype1 == ActionResultType.FAIL) {
                                     return;
                                 }
                         }
                     }
+                    //pi stuff
+                    physicalGuiManager.preClickAction();
+                    //
+                    //Forge
+                    if (itemstack.isEmpty() && (this.objectMouseOver == null || this.objectMouseOver.getType() == RayTraceResult.Type.MISS))
+                        Reflector.call(Reflector.ForgeHooks_onEmptyClick, this.player, hand);
+                    //
+                    if (!itemstack.isEmpty()) {
 
-                    if (!itemstack.isEmpty())
-                    {
                         ActionResultType actionresulttype2 = this.playerController.processRightClick(this.player, this.world, hand);
 
-                        if (actionresulttype2.isSuccessOrConsume())
-                        {
-                            if (actionresulttype2.isSuccess())
-                            {
-                                this.player.swingArm(hand);
+                        if (actionresulttype2.isSuccessOrConsume()) {
+                            if (actionresulttype2.isSuccess()) {
+                                //Vivecraft
+                                this.player.swingArm(hand, VRFirstPersonArmSwing.Use);
+                                //
                             }
 
                             this.gameRenderer.itemRenderer.resetEquippedProgress(hand);
@@ -1687,136 +1950,143 @@
     /**
      * Return the musicTicker's instance
      */
-    public MusicTicker getMusicTicker()
-    {
+    public MusicTicker getMusicTicker() {
         return this.musicTicker;
     }
 
     /**
      * Runs the current tick.
      */
-    public void runTick()
-    {
-        if (this.rightClickDelayTimer > 0)
-        {
+    public void runTick() {
+        //Vivecraft y do we put this here
+        this.tickCounter++;
+        //
+        if (this.rightClickDelayTimer > 0) {
             --this.rightClickDelayTimer;
         }
+        //Forge
+        Reflector.call(Reflector.BasicEventHooks_onPreClientTick);
+        //
+        this.profiler.startSection("guitick");
 
-        this.profiler.startSection("gui");
-
-        if (!this.isGamePaused)
-        {
+        if (!this.isGamePaused) {
             this.ingameGUI.tick();
         }
 
         this.profiler.endSection();
-        this.gameRenderer.getMouseOver(1.0F);
+        //this.gameRenderer.getMouseOver(1.0F);
         this.tutorial.onMouseHover(this.world, this.objectMouseOver);
         this.profiler.startSection("gameMode");
 
-        if (!this.isGamePaused && this.world != null)
-        {
+        if (!this.isGamePaused && this.world != null) {
             this.playerController.tick();
         }
 
         this.profiler.endStartSection("textures");
 
-        if (this.world != null)
-        {
-            this.textureManager.tick();
-        }
-
-        if (this.currentScreen == null && this.player != null)
-        {
-            if (this.player.getShouldBeDead() && !(this.currentScreen instanceof DeathScreen))
-            {
-                this.displayGuiScreen((Screen)null);
-            }
-            else if (this.player.isSleeping() && this.world != null)
-            {
+        // Vivecraft tick the main menu too
+        // if (this.world != null)
+        // {
+        this.textureManager.tick();
+        // }
+
+        if (this.currentScreen == null && this.player != null) {
+            if (this.player.getShouldBeDead() && !(this.currentScreen instanceof DeathScreen)) {
+                this.displayGuiScreen(null);
+            } else if (this.player.isSleeping() && this.world != null) {
                 this.displayGuiScreen(new SleepInMultiplayerScreen());
             }
-        }
-        else if (this.currentScreen != null && this.currentScreen instanceof SleepInMultiplayerScreen && !this.player.isSleeping())
-        {
-            this.displayGuiScreen((Screen)null);
+        } else if (this.currentScreen != null && this.currentScreen instanceof SleepInMultiplayerScreen && !this.player.isSleeping()) {
+            this.displayGuiScreen(null);
         }
 
-        if (this.currentScreen != null)
-        {
+        if (this.currentScreen != null) {
             this.leftClickCounter = 10000;
         }
 
-        if (this.currentScreen != null)
-        {
+        if (this.currentScreen != null) {
             Screen.wrapScreenError(() ->
-            {
-                this.currentScreen.tick();
-            }, "Ticking screen", this.currentScreen.getClass().getCanonicalName());
+                    this.currentScreen.tick(), "Ticking screen", this.currentScreen.getClass().getCanonicalName());
         }
 
-        if (!this.gameSettings.showDebugInfo)
-        {
+        if (!this.gameSettings.showDebugInfo) {
             this.ingameGUI.reset();
         }
+        // Vivecraft
+        this.profiler.endStartSection("vrProcessInputs");
+        MCOpenVR.processInputs();
+        MCOpenVR.processBindings();
+        ///
 
-        if (this.loadingGui == null && (this.currentScreen == null || this.currentScreen.passEvents))
-        {
+        if (this.loadingGui == null && (this.currentScreen == null || this.currentScreen.passEvents)) {
             this.profiler.endStartSection("Keybindings");
             this.processKeyBinds();
 
-            if (this.leftClickCounter > 0)
-            {
+            if (this.leftClickCounter > 0) {
                 --this.leftClickCounter;
             }
         }
 
-        if (this.world != null)
-        {
+        // Vivecraft
+        this.profiler.endStartSection("vrInputActionsTick");
+        for (VRInputAction action : MCOpenVR.getInputActions()) {
+            action.tick();
+        }
+
+        if (vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY
+                || vrSettings.displayMirrorMode == VRSettings.MIRROR_THIRD_PERSON)
+            VRHotkeys.handleMRKeys();
+
+        if (this.world != null) {
+            if (this.player != null) {
+                // Vivecraft
+                this.vrPlayer.updateFreeMove();
+                if (this.vrPlayer.teleportWarningTimer >= 0) {
+                    if (--this.vrPlayer.teleportWarningTimer == 0) {
+                        this.ingameGUI.getChatGUI().printChatMessage(new TranslationTextComponent("vivecraft.messages.noserverplugin"));
+                    }
+                }
+            }
             this.profiler.endStartSection("gameRenderer");
 
-            if (!this.isGamePaused)
-            {
+            if (!this.isGamePaused) {
                 this.gameRenderer.tick();
             }
 
             this.profiler.endStartSection("levelRenderer");
 
-            if (!this.isGamePaused)
-            {
+            if (!this.isGamePaused) {
                 this.worldRenderer.tick();
             }
 
             this.profiler.endStartSection("level");
 
-            if (!this.isGamePaused)
-            {
-                if (this.world.getTimeLightningFlash() > 0)
-                {
+            if (!this.isGamePaused) {
+                if (this.world.getTimeLightningFlash() > 0) {
                     this.world.setTimeLightningFlash(this.world.getTimeLightningFlash() - 1);
                 }
 
                 this.world.tickEntities();
             }
-        }
-        else if (this.gameRenderer.getShaderGroup() != null)
-        {
+        } else if (this.gameRenderer.getShaderGroup() != null) {
             this.gameRenderer.stopUseShader();
         }
 
-        if (!this.isGamePaused)
-        {
+        // Vivecraft
+        if (this.menuWorldRenderer != null)
+            this.menuWorldRenderer.tick();
+        PlayerModelController.getInstance().tick();
+        //
+
+        if (!this.isGamePaused) {
             this.musicTicker.tick();
         }
 
         this.soundHandler.tick(this.isGamePaused);
 
-        if (this.world != null)
-        {
-            if (!this.isGamePaused)
-            {
-                if (!this.gameSettings.field_244601_E && this.func_244600_aM())
-                {
+        if (this.world != null) {
+            if (!this.isGamePaused) {
+                if (!this.gameSettings.field_244601_E && this.func_244600_aM()) {
                     ITextComponent itextcomponent = new TranslationTextComponent("tutorial.socialInteractions.title");
                     ITextComponent itextcomponent1 = new TranslationTextComponent("tutorial.socialInteractions.description", Tutorial.createKeybindComponent("socialInteractions"));
                     this.field_244598_aV = new TutorialToast(TutorialToast.Icons.SOCIAL_INTERACTIONS, itextcomponent, itextcomponent1, true);
@@ -1827,24 +2097,16 @@
 
                 this.tutorial.tick();
 
-                try
-                {
+                try {
                     this.world.tick(() ->
-                    {
-                        return true;
-                    });
-                }
-                catch (Throwable throwable)
-                {
+                            true);
+                } catch (Throwable throwable) {
                     CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception in world tick");
 
-                    if (this.world == null)
-                    {
+                    if (this.world == null) {
                         CrashReportCategory crashreportcategory = crashreport.makeCategory("Affected level");
                         crashreportcategory.addDetail("Problem", "Level is null!");
-                    }
-                    else
-                    {
+                    } else {
                         this.world.fillCrashReport(crashreport);
                     }
 
@@ -1854,20 +2116,16 @@
 
             this.profiler.endStartSection("animateTick");
 
-            if (!this.isGamePaused && this.world != null)
-            {
+            if (!this.isGamePaused && this.world != null) {
                 this.world.animateTick(MathHelper.floor(this.player.getPosX()), MathHelper.floor(this.player.getPosY()), MathHelper.floor(this.player.getPosZ()));
             }
 
             this.profiler.endStartSection("particles");
 
-            if (!this.isGamePaused)
-            {
+            if (!this.isGamePaused) {
                 this.particles.tick();
             }
-        }
-        else if (this.networkManager != null)
-        {
+        } else if (this.networkManager != null) {
             this.profiler.endStartSection("pendingConnection");
             this.networkManager.tick();
         }
@@ -1875,64 +2133,56 @@
         this.profiler.endStartSection("keyboard");
         this.keyboardListener.tick();
         this.profiler.endSection();
+        //Forge
+        Reflector.call(Reflector.BasicEventHooks_onPostClientTick);
+        //
     }
 
-    private boolean func_244600_aM()
-    {
+    //IsMultiplayer
+    public boolean func_244600_aM() {
         return !this.integratedServerIsRunning || this.integratedServer != null && this.integratedServer.getPublic();
     }
 
-    private void processKeyBinds()
-    {
-        for (; this.gameSettings.keyBindTogglePerspective.isPressed(); this.worldRenderer.setDisplayListEntitiesDirty())
-        {
-            PointOfView pointofview = this.gameSettings.getPointOfView();
-            this.gameSettings.setPointOfView(this.gameSettings.getPointOfView().func_243194_c());
-
-            if (pointofview.func_243192_a() != this.gameSettings.getPointOfView().func_243192_a())
-            {
-                this.gameRenderer.loadEntityShader(this.gameSettings.getPointOfView().func_243192_a() ? this.getRenderViewEntity() : null);
-            }
+    private void processKeyBinds() {
+        for (; this.gameSettings.keyBindTogglePerspective.isPressed(); this.worldRenderer.setDisplayListEntitiesDirty()) {
+            //Vivecraft cycle mirror mode
+            vrSettings.setOptionValue(VrOptions.MIRROR_DISPLAY);
+            notifyMirror(vrSettings.getButtonDisplayString(VrOptions.MIRROR_DISPLAY), false, 3000);
+            //
+            //            PointOfView pointofview = this.gameSettings.func_243230_g();
+            //            this.gameSettings.func_243229_a(this.gameSettings.func_243230_g().func_243194_c());
+            //
+            //            if (pointofview.func_243192_a() != this.gameSettings.func_243230_g().func_243192_a())
+            //            {
+            //                this.gameRenderer.loadEntityShader(this.gameSettings.func_243230_g().func_243192_a() ? this.getRenderViewEntity() : null);
+            //            }
         }
 
-        while (this.gameSettings.keyBindSmoothCamera.isPressed())
-        {
+        while (this.gameSettings.keyBindSmoothCamera.isPressed()) {
             this.gameSettings.smoothCamera = !this.gameSettings.smoothCamera;
         }
 
-        for (int i = 0; i < 9; ++i)
-        {
+        for (int i = 0; i < 9; ++i) {
             boolean flag = this.gameSettings.keyBindSaveToolbar.isKeyDown();
             boolean flag1 = this.gameSettings.keyBindLoadToolbar.isKeyDown();
 
-            if (this.gameSettings.keyBindsHotbar[i].isPressed())
-            {
-                if (this.player.isSpectator())
-                {
+            if (this.gameSettings.keyBindsHotbar[i].isPressed()) {
+                if (this.player.isSpectator()) {
                     this.ingameGUI.getSpectatorGui().onHotbarSelected(i);
-                }
-                else if (!this.player.isCreative() || this.currentScreen != null || !flag1 && !flag)
-                {
+                } else if (!this.player.isCreative() || this.currentScreen != null || !flag1 && !flag) {
                     this.player.inventory.currentItem = i;
-                }
-                else
-                {
+                } else {
                     CreativeScreen.handleHotbarSnapshots(this, i, flag1, flag);
                 }
             }
         }
 
-        while (this.gameSettings.field_244602_au.isPressed())
-        {
-            if (!this.func_244600_aM())
-            {
+        while (this.gameSettings.field_244602_au.isPressed()) {
+            if (!this.func_244600_aM()) {
                 this.player.sendStatusMessage(field_244596_I, true);
                 NarratorChatListener.INSTANCE.say(field_244596_I.getString());
-            }
-            else
-            {
-                if (this.field_244598_aV != null)
-                {
+            } else {
+                if (this.field_244598_aV != null) {
                     this.tutorial.func_244697_a(this.field_244598_aV);
                     this.field_244598_aV = null;
                 }
@@ -1941,188 +2191,138 @@
             }
         }
 
-        while (this.gameSettings.keyBindInventory.isPressed())
-        {
-            if (this.playerController.isRidingHorse())
-            {
+        while (this.gameSettings.keyBindInventory.isPressed()) {
+            if (this.playerController.isRidingHorse()) {
                 this.player.sendHorseInventory();
-            }
-            else
-            {
+            } else {
                 this.tutorial.openInventory();
                 this.displayGuiScreen(new InventoryScreen(this.player));
             }
         }
 
-        while (this.gameSettings.keyBindAdvancements.isPressed())
-        {
+        while (this.gameSettings.keyBindAdvancements.isPressed()) {
             this.displayGuiScreen(new AdvancementsScreen(this.player.connection.getAdvancementManager()));
         }
 
-        while (this.gameSettings.keyBindSwapHands.isPressed())
-        {
-            if (!this.player.isSpectator())
-            {
+        while (this.gameSettings.keyBindSwapHands.isPressed()) {
+            if (!this.player.isSpectator()) {
                 this.getConnection().sendPacket(new CPlayerDiggingPacket(CPlayerDiggingPacket.Action.SWAP_ITEM_WITH_OFFHAND, BlockPos.ZERO, Direction.DOWN));
             }
         }
 
-        while (this.gameSettings.keyBindDrop.isPressed())
-        {
-            if (!this.player.isSpectator() && this.player.drop(Screen.hasControlDown()))
-            {
-                this.player.swingArm(Hand.MAIN_HAND);
+        while (this.gameSettings.keyBindDrop.isPressed()) {
+            if (!this.player.isSpectator() && this.player.drop(Screen.hasControlDown())) {
+                //Vivecraft - thow anim?
+                this.player.swingArm(Hand.MAIN_HAND, VRFirstPersonArmSwing.Attack);
+                //
             }
         }
 
         boolean flag2 = this.gameSettings.chatVisibility != ChatVisibility.HIDDEN;
 
-        if (flag2)
-        {
-            while (this.gameSettings.keyBindChat.isPressed())
-            {
+        if (flag2) {
+            if (this.currentScreen == null && this.gameSettings.keyBindChat.isPressed()) {
                 this.openChatScreen("");
             }
 
-            if (this.currentScreen == null && this.loadingGui == null && this.gameSettings.keyBindCommand.isPressed())
-            {
+            if (this.currentScreen == null && this.loadingGui == null && this.gameSettings.keyBindCommand.isPressed()) {
                 this.openChatScreen("/");
             }
         }
 
-        if (this.player.isHandActive())
-        {
-            if (!this.gameSettings.keyBindUseItem.isKeyDown())
-            {
-                this.playerController.onStoppedUsingItem(this.player);
+        if (this.player.isHandActive()) {
+            if (!this.gameSettings.keyBindUseItem.isKeyDown()
+                    && (!bowTracker.isActive(player) || vrSettings.seated)) {
+                if (!autoFood.isEating()) {
+                    NetworkHelper.sendActiveHand((byte) player.getActiveHand().ordinal());
+                    this.playerController.onStoppedUsingItem(this.player);
+                }
             }
 
-            while (this.gameSettings.keyBindAttack.isPressed())
-            {
+            while (this.gameSettings.keyBindAttack.isPressed()) {
             }
 
-            while (this.gameSettings.keyBindUseItem.isPressed())
-            {
+            while (this.gameSettings.keyBindUseItem.isPressed()) {
             }
 
-            while (this.gameSettings.keyBindPickBlock.isPressed())
-            {
+            while (this.gameSettings.keyBindPickBlock.isPressed()) {
             }
-        }
-        else
-        {
-            while (this.gameSettings.keyBindAttack.isPressed())
-            {
+        } else {
+            // VIVE SUPPORT HAND SWINGING
+            if (this.gameSettings.keyBindAttack.isPressed() && currentScreen == null) {
                 this.clickMouse();
+                lastClick = true;
+            } else if (!this.gameSettings.keyBindAttack.isKeyDown()) {
+                this.leftClickCounter = 0;
+                if (lastClick) {
+                    this.playerController.resetBlockRemoving();
+                }
+                lastClick = false;
             }
+            /// END VIVE
 
-            while (this.gameSettings.keyBindUseItem.isPressed())
-            {
+            while (this.gameSettings.keyBindUseItem.isPressed()) {
                 this.rightClickMouse();
             }
 
-            while (this.gameSettings.keyBindPickBlock.isPressed())
-            {
+            while (this.gameSettings.keyBindPickBlock.isPressed()) {
                 this.middleClickMouse();
             }
         }
 
-        if (this.gameSettings.keyBindUseItem.isKeyDown() && this.rightClickDelayTimer == 0 && !this.player.isHandActive())
-        {
+        if (this.gameSettings.keyBindUseItem.isKeyDown() && this.rightClickDelayTimer == 0 && !this.player.isHandActive()) {
             this.rightClickMouse();
         }
 
-        this.sendClickBlockToController(this.currentScreen == null && this.gameSettings.keyBindAttack.isKeyDown() && this.mouseHelper.isMouseGrabbed());
-    }
-
-    public static DatapackCodec loadDataPackCodec(SaveFormat.LevelSave worldStorage)
-    {
-        MinecraftServer.func_240777_a_(worldStorage);
-        DatapackCodec datapackcodec = worldStorage.readDatapackCodec();
-
-        if (datapackcodec == null)
-        {
-            throw new IllegalStateException("Failed to load data pack config");
-        }
-        else
-        {
-            return datapackcodec;
-        }
-    }
-
-    public static IServerConfiguration loadWorld(SaveFormat.LevelSave worldStorage, DynamicRegistries.Impl dynamicRegistries, IResourceManager resourceManager, DatapackCodec datapackCodec)
-    {
-        WorldSettingsImport<INBT> worldsettingsimport = WorldSettingsImport.create(NBTDynamicOps.INSTANCE, resourceManager, dynamicRegistries);
-        IServerConfiguration iserverconfiguration = worldStorage.readServerConfiguration(worldsettingsimport, datapackCodec);
-
-        if (iserverconfiguration == null)
-        {
-            throw new IllegalStateException("Failed to load world");
-        }
-        else
-        {
-            return iserverconfiguration;
-        }
+        this.sendClickBlockToController(this.currentScreen == null && this.gameSettings.keyBindAttack.isKeyDown());
     }
 
-    public void loadWorld(String worldName)
-    {
-        this.loadWorld(worldName, DynamicRegistries.func_239770_b_(), Minecraft::loadDataPackCodec, Minecraft::loadWorld, false, Minecraft.WorldSelectionType.BACKUP);
+    public void loadWorld(String worldName) {
+        this.loadWorld(worldName, DynamicRegistries.func_239770_b_(), Minecraft::loadDataPackCodec, Minecraft::loadWorld, false, Minecraft.WorldSelectionType.BACKUP, false);
     }
 
-    public void createWorld(String worldName, WorldSettings worldSettings, DynamicRegistries.Impl dynamicRegistriesIn, DimensionGeneratorSettings dimensionGeneratorSettings)
-    {
+    public void createWorld(String worldName, WorldSettings worldSettings, DynamicRegistries.Impl dynamicRegistriesIn, DimensionGeneratorSettings dimensionGeneratorSettings) {
         this.loadWorld(worldName, dynamicRegistriesIn, (worldStorage) ->
-        {
-            return worldSettings.getDatapackCodec();
-        }, (worldStorage, dynamicRegistries, resourceManager, datapackCodec) ->
+                worldSettings.getDatapackCodec(), (worldStorage, dynamicRegistries, resourceManager, datapackCodec) ->
         {
             WorldGenSettingsExport<JsonElement> worldgensettingsexport = WorldGenSettingsExport.create(JsonOps.INSTANCE, dynamicRegistriesIn);
             WorldSettingsImport<JsonElement> worldsettingsimport = WorldSettingsImport.create(JsonOps.INSTANCE, resourceManager, dynamicRegistriesIn);
-            DataResult<DimensionGeneratorSettings> dataresult = DimensionGeneratorSettings.field_236201_a_.encodeStart(worldgensettingsexport, dimensionGeneratorSettings).setLifecycle(Lifecycle.stable()).flatMap((p_243209_1_) -> {
-                return DimensionGeneratorSettings.field_236201_a_.parse(worldsettingsimport, p_243209_1_);
-            });
+            DataResult<DimensionGeneratorSettings> dataresult = DimensionGeneratorSettings.field_236201_a_.encodeStart(worldgensettingsexport, dimensionGeneratorSettings).setLifecycle(Lifecycle.stable()).flatMap((p_243209_1_) -> DimensionGeneratorSettings.field_236201_a_.parse(worldsettingsimport, p_243209_1_));
             DimensionGeneratorSettings dimensiongeneratorsettings = dataresult.resultOrPartial(Util.func_240982_a_("Error reading worldgen settings after loading data packs: ", LOGGER::error)).orElse(dimensionGeneratorSettings);
             return new ServerWorldInfo(worldSettings, dimensiongeneratorsettings, dataresult.lifecycle());
-        }, false, Minecraft.WorldSelectionType.CREATE);
+        }, false, Minecraft.WorldSelectionType.CREATE, true);
     }
 
-    private void loadWorld(String worldName, DynamicRegistries.Impl dynamicRegistries, Function<SaveFormat.LevelSave, DatapackCodec> levelSaveToDatapackFunction, Function4<SaveFormat.LevelSave, DynamicRegistries.Impl, IResourceManager, DatapackCodec, IServerConfiguration> quadFunction, boolean vanillaOnly, Minecraft.WorldSelectionType selectionType)
-    {
+    // Forge does this crap
+    private void loadWorld(String worldName, DynamicRegistries.Impl dynamicRegistries, Function<SaveFormat.LevelSave, DatapackCodec> levelSaveToDatapackFunction, Function4<SaveFormat.LevelSave, DynamicRegistries.Impl, IResourceManager, DatapackCodec, IServerConfiguration> quadFunction, boolean vanillaOnly, Minecraft.WorldSelectionType selectionType, boolean creating) {
         SaveFormat.LevelSave saveformat$levelsave;
 
-        try
-        {
+        try {
             saveformat$levelsave = this.saveFormat.getLevelSave(worldName);
-        }
-        catch (IOException ioexception2)
-        {
+        } catch (IOException ioexception2) {
             LOGGER.warn("Failed to read level {} data", worldName, ioexception2);
             SystemToast.func_238535_a_(this, worldName);
-            this.displayGuiScreen((Screen)null);
+            this.displayGuiScreen(null);
             return;
         }
 
         Minecraft.PackManager minecraft$packmanager;
+        final DynamicRegistries.Impl dyn_f;
 
-        try
-        {
-            minecraft$packmanager = this.reloadDatapacks(dynamicRegistries, levelSaveToDatapackFunction, quadFunction, vanillaOnly, saveformat$levelsave);
-        }
-        catch (Exception exception)
-        {
-            LOGGER.warn("Failed to load datapacks, can't proceed with server load", (Throwable)exception);
+        try {
+            // FORGE
+            Minecraft.PackManager mgr = this.reloadDatapacks(dynamicRegistries, levelSaveToDatapackFunction, quadFunction, vanillaOnly, saveformat$levelsave);
+            dyn_f = creating ? dynamicRegistries : DynamicRegistries.func_239770_b_();
+            minecraft$packmanager = creating ? mgr : this.reloadDatapacks(dyn_f, levelSaveToDatapackFunction, quadFunction, vanillaOnly, saveformat$levelsave);
+            // END FORGE
+        } catch (Exception exception) {
+            LOGGER.warn("Failed to load datapacks, can't proceed with server load", exception);
             this.displayGuiScreen(new DatapackFailureScreen(() ->
-            {
-                this.loadWorld(worldName, dynamicRegistries, levelSaveToDatapackFunction, quadFunction, true, selectionType);
-            }));
+                    this.loadWorld(worldName, dynamicRegistries, levelSaveToDatapackFunction, quadFunction, true, selectionType, creating)));
 
-            try
-            {
+            try {
                 saveformat$levelsave.close();
-            }
-            catch (IOException ioexception)
-            {
+            } catch (IOException ioexception) {
                 LOGGER.warn("Failed to unlock access to level {}", worldName, ioexception);
             }
 
@@ -2133,14 +2333,12 @@
         boolean flag = iserverconfiguration.getDimensionGeneratorSettings().func_236229_j_();
         boolean flag1 = iserverconfiguration.getLifecycle() != Lifecycle.stable();
 
-        if (selectionType == Minecraft.WorldSelectionType.NONE || !flag && !flag1)
-        {
+        if (selectionType == Minecraft.WorldSelectionType.NONE || !flag && !flag1) {
             this.unloadWorld();
-            this.refChunkStatusListener.set((TrackingChunkStatusListener)null);
+            this.refChunkStatusListener.set(null);
 
-            try
-            {
-                saveformat$levelsave.saveLevel(dynamicRegistries, iserverconfiguration);
+            try {
+                saveformat$levelsave.saveLevel(dyn_f, iserverconfiguration);
                 minecraft$packmanager.getDataPackRegistries().updateTags();
                 YggdrasilAuthenticationService yggdrasilauthenticationservice = new YggdrasilAuthenticationService(this.proxy);
                 MinecraftSessionService minecraftsessionservice = yggdrasilauthenticationservice.createMinecraftSessionService();
@@ -2150,18 +2348,14 @@
                 SkullTileEntity.setSessionService(minecraftsessionservice);
                 PlayerProfileCache.setOnlineMode(false);
                 this.integratedServer = MinecraftServer.func_240784_a_((thread) ->
-                {
-                    return new IntegratedServer(thread, this, dynamicRegistries, saveformat$levelsave, minecraft$packmanager.getResourcePacks(), minecraft$packmanager.getDataPackRegistries(), iserverconfiguration, minecraftsessionservice, gameprofilerepository, playerprofilecache, (radius) -> {
-                        TrackingChunkStatusListener trackingchunkstatuslistener = new TrackingChunkStatusListener(radius + 0);
-                        trackingchunkstatuslistener.startTracking();
-                        this.refChunkStatusListener.set(trackingchunkstatuslistener);
-                        return new ChainedChunkStatusListener(trackingchunkstatuslistener, this.queueChunkTracking::add);
-                    });
-                });
+                        new IntegratedServer(thread, this, dyn_f, saveformat$levelsave, minecraft$packmanager.getResourcePacks(), minecraft$packmanager.getDataPackRegistries(), iserverconfiguration, minecraftsessionservice, gameprofilerepository, playerprofilecache, (radius) -> {
+                            TrackingChunkStatusListener trackingchunkstatuslistener = new TrackingChunkStatusListener(radius);
+                            trackingchunkstatuslistener.startTracking();
+                            this.refChunkStatusListener.set(trackingchunkstatuslistener);
+                            return new ChainedChunkStatusListener(trackingchunkstatuslistener, this.queueChunkTracking::add);
+                        }));
                 this.integratedServerIsRunning = true;
-            }
-            catch (Throwable throwable)
-            {
+            } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Starting integrated server");
                 CrashReportCategory crashreportcategory = crashreport.makeCategory("Starting integrated server");
                 crashreportcategory.addDetail("Level ID", worldName);
@@ -2169,8 +2363,7 @@
                 throw new ReportedException(crashreport);
             }
 
-            while (this.refChunkStatusListener.get() == null)
-            {
+            while (this.refChunkStatusListener.get() == null) {
                 Thread.yield();
             }
 
@@ -2178,21 +2371,16 @@
             this.displayGuiScreen(worldloadprogressscreen);
             this.profiler.startSection("waitForServer");
 
-            while (!this.integratedServer.serverIsInRunLoop())
-            {
+            while (!this.integratedServer.serverIsInRunLoop()) {
                 worldloadprogressscreen.tick();
                 this.runGameLoop(false);
 
-                try
-                {
+                try {
                     Thread.sleep(16L);
-                }
-                catch (InterruptedException interruptedexception)
-                {
+                } catch (InterruptedException ignored) {
                 }
 
-                if (this.crashReporter != null)
-                {
+                if (this.crashReporter != null) {
                     displayCrashReport(this.crashReporter);
                     return;
                 }
@@ -2201,77 +2389,64 @@
             this.profiler.endSection();
             SocketAddress socketaddress = this.integratedServer.getNetworkSystem().addLocalEndpoint();
             NetworkManager networkmanager = NetworkManager.provideLocalClient(socketaddress);
-            networkmanager.setNetHandler(new ClientLoginNetHandler(networkmanager, this, (Screen)null, (statusMessage) ->
+            networkmanager.setNetHandler(new ClientLoginNetHandler(networkmanager, this, null, (statusMessage) ->
             {
             }));
             networkmanager.sendPacket(new CHandshakePacket(socketaddress.toString(), 0, ProtocolType.LOGIN));
+            //Forge
+            com.mojang.authlib.GameProfile gameProfile = this.getSession().getProfile();
+            if ((Reflector.ForgeSession_hasCachedProperties.exists() && !Reflector.callBoolean(this.getSession(), Reflector.ForgeSession_hasCachedProperties))) {
+                gameProfile = sessionService.fillProfileProperties(gameProfile, true); //Forge: Fill profile properties upon game load. Fixes MC-52974.
+                Reflector.call(this.getSession(), Reflector.ForgeSession_setProperties, gameProfile.getProperties());
+            }
+            //
             networkmanager.sendPacket(new CLoginStartPacket(this.getSession().getProfile()));
             this.networkManager = networkmanager;
-        }
-        else
-        {
+        } else {
             this.deleteWorld(selectionType, worldName, flag, () ->
-            {
-                this.loadWorld(worldName, dynamicRegistries, levelSaveToDatapackFunction, quadFunction, vanillaOnly, Minecraft.WorldSelectionType.NONE);
-            });
+                    this.loadWorld(worldName, dynamicRegistries, levelSaveToDatapackFunction, quadFunction, vanillaOnly, WorldSelectionType.NONE, creating));
             minecraft$packmanager.close();
 
-            try
-            {
+            try {
                 saveformat$levelsave.close();
-            }
-            catch (IOException ioexception1)
-            {
+            } catch (IOException ioexception1) {
                 LOGGER.warn("Failed to unlock access to level {}", worldName, ioexception1);
             }
         }
     }
 
-    private void deleteWorld(Minecraft.WorldSelectionType selectionType, String worldName, boolean customized, Runnable runnable)
-    {
-        if (selectionType == Minecraft.WorldSelectionType.BACKUP)
-        {
+    private void deleteWorld(Minecraft.WorldSelectionType selectionType, String worldName, boolean customized, Runnable runnable) {
+        if (selectionType == Minecraft.WorldSelectionType.BACKUP) {
             ITextComponent itextcomponent;
             ITextComponent itextcomponent1;
 
-            if (customized)
-            {
+            if (customized) {
                 itextcomponent = new TranslationTextComponent("selectWorld.backupQuestion.customized");
                 itextcomponent1 = new TranslationTextComponent("selectWorld.backupWarning.customized");
-            }
-            else
-            {
+            } else {
                 itextcomponent = new TranslationTextComponent("selectWorld.backupQuestion.experimental");
                 itextcomponent1 = new TranslationTextComponent("selectWorld.backupWarning.experimental");
             }
 
-            this.displayGuiScreen(new ConfirmBackupScreen((Screen)null, (editMode, checkedBox) ->
+            this.displayGuiScreen(new ConfirmBackupScreen(null, (editMode, checkedBox) ->
             {
-                if (editMode)
-                {
+                if (editMode) {
                     EditWorldScreen.func_241651_a_(this.saveFormat, worldName);
                 }
 
                 runnable.run();
             }, itextcomponent, itextcomponent1, false));
-        }
-        else
-        {
+        } else {
             this.displayGuiScreen(new ConfirmScreen((confirm) ->
             {
-                if (confirm)
-                {
+                if (confirm) {
                     runnable.run();
-                }
-                else {
-                    this.displayGuiScreen((Screen)null);
+                } else {
+                    this.displayGuiScreen(null);
 
-                    try (SaveFormat.LevelSave saveformat$levelsave = this.saveFormat.getLevelSave(worldName))
-                    {
+                    try (SaveFormat.LevelSave saveformat$levelsave = this.saveFormat.getLevelSave(worldName)) {
                         saveformat$levelsave.deleteSave();
-                    }
-                    catch (IOException ioexception)
-                    {
+                    } catch (IOException ioexception) {
                         SystemToast.func_238538_b_(this, worldName);
                         LOGGER.error("Failed to delete world {}", worldName, ioexception);
                     }
@@ -2280,22 +2455,18 @@
         }
     }
 
-    public Minecraft.PackManager reloadDatapacks(DynamicRegistries.Impl dynamicRegistries, Function<SaveFormat.LevelSave, DatapackCodec> worldStorageToDatapackFunction, Function4<SaveFormat.LevelSave, DynamicRegistries.Impl, IResourceManager, DatapackCodec, IServerConfiguration> quadFunction, boolean vanillaOnly, SaveFormat.LevelSave worldStorage) throws InterruptedException, ExecutionException
-    {
+    public Minecraft.PackManager reloadDatapacks(DynamicRegistries.Impl dynamicRegistries, Function<SaveFormat.LevelSave, DatapackCodec> worldStorageToDatapackFunction, Function4<SaveFormat.LevelSave, DynamicRegistries.Impl, IResourceManager, DatapackCodec, IServerConfiguration> quadFunction, boolean vanillaOnly, SaveFormat.LevelSave worldStorage) throws InterruptedException, ExecutionException {
         DatapackCodec datapackcodec = worldStorageToDatapackFunction.apply(worldStorage);
         ResourcePackList resourcepacklist = new ResourcePackList(new ServerPackFinder(), new FolderPackFinder(worldStorage.resolveFilePath(FolderName.DATAPACKS).toFile(), IPackNameDecorator.WORLD));
 
-        try
-        {
+        try {
             DatapackCodec datapackcodec1 = MinecraftServer.func_240772_a_(resourcepacklist, datapackcodec, vanillaOnly);
             CompletableFuture<DataPackRegistries> completablefuture = DataPackRegistries.func_240961_a_(resourcepacklist.func_232623_f_(), Commands.EnvironmentType.INTEGRATED, 2, Util.getServerExecutor(), this);
             this.driveUntil(completablefuture::isDone);
             DataPackRegistries datapackregistries = completablefuture.get();
             IServerConfiguration iserverconfiguration = quadFunction.apply(worldStorage, dynamicRegistries, datapackregistries.getResourceManager(), datapackcodec1);
             return new Minecraft.PackManager(resourcepacklist, datapackregistries, iserverconfiguration);
-        }
-        catch (ExecutionException | InterruptedException interruptedexception)
-        {
+        } catch (ExecutionException | InterruptedException interruptedexception) {
             resourcepacklist.close();
             throw interruptedexception;
         }
@@ -2304,16 +2475,21 @@
     /**
      * unloads the current world first
      */
-    public void loadWorld(ClientWorld worldClientIn)
-    {
+    public void loadWorld(ClientWorld worldClientIn) {
+        // VIVE START - reset room origin
+        vrPlayer.setRoomOrigin(0, 0, 0, true);
+        // VIVE END - reset room origin
+        //Forge
+        if (world != null)
+            Reflector.postForgeBusEvent(Reflector.newInstance(Reflector.WorldEvent_Unload_Constructor, world));
+        //
         WorkingScreen workingscreen = new WorkingScreen();
         workingscreen.displaySavingString(new TranslationTextComponent("connect.joining"));
         this.updateScreenTick(workingscreen);
         this.world = worldClientIn;
         this.updateWorldRenderer(worldClientIn);
 
-        if (!this.integratedServerIsRunning)
-        {
+        if (!this.integratedServerIsRunning) {
             AuthenticationService authenticationservice = new YggdrasilAuthenticationService(this.proxy);
             MinecraftSessionService minecraftsessionservice = authenticationservice.createMinecraftSessionService();
             GameProfileRepository gameprofilerepository = authenticationservice.createProfileRepository();
@@ -2324,17 +2500,14 @@
         }
     }
 
-    public void unloadWorld()
-    {
+    public void unloadWorld() {
         this.unloadWorld(new WorkingScreen());
     }
 
-    public void unloadWorld(Screen screenIn)
-    {
+    public void unloadWorld(Screen screenIn) {
         ClientPlayNetHandler clientplaynethandler = this.getConnection();
 
-        if (clientplaynethandler != null)
-        {
+        if (clientplaynethandler != null) {
             this.dropTasks();
             clientplaynethandler.cleanup();
         }
@@ -2342,18 +2515,21 @@
         IntegratedServer integratedserver = this.integratedServer;
         this.integratedServer = null;
         this.gameRenderer.resetData();
+        //Forge
+        Reflector.call(Reflector.ClientHooks_firePlayerLogout, this.playerController, this.player);
+        //
         this.playerController = null;
         NarratorChatListener.INSTANCE.clear();
         this.updateScreenTick(screenIn);
 
-        if (this.world != null)
-        {
-            if (integratedserver != null)
-            {
+        if (this.world != null) {
+            //forge
+            Reflector.postForgeBusEvent(Reflector.newInstance(Reflector.WorldEvent_Unload_Constructor, world));
+            //
+            if (integratedserver != null) {
                 this.profiler.startSection("waitForServer");
 
-                while (!integratedserver.isThreadAlive())
-                {
+                while (!integratedserver.isThreadAlive()) {
                     this.runGameLoop(false);
                 }
 
@@ -2364,16 +2540,18 @@
             this.ingameGUI.resetPlayersOverlayFooterHeader();
             this.currentServerData = null;
             this.integratedServerIsRunning = false;
+            //forge
+            Reflector.call(Reflector.ClientHooks_handleClientWorldClosing, world);
+            //
             this.game.leaveGameSession();
         }
 
         this.world = null;
-        this.updateWorldRenderer((ClientWorld)null);
+        this.updateWorldRenderer(null);
         this.player = null;
     }
 
-    private void updateScreenTick(Screen screenIn)
-    {
+    private void updateScreenTick(Screen screenIn) {
         this.profiler.startSection("forcedTick");
         this.soundHandler.stop();
         this.renderViewEntity = null;
@@ -2383,154 +2561,114 @@
         this.profiler.endSection();
     }
 
-    public void forcedScreenTick(Screen screen)
-    {
+    public void forcedScreenTick(Screen screen) {
         this.profiler.startSection("forcedTick");
         this.displayGuiScreen(screen);
         this.runGameLoop(false);
         this.profiler.endSection();
     }
 
-    private void updateWorldRenderer(@Nullable ClientWorld worldIn)
-    {
+    private void updateWorldRenderer(@Nullable ClientWorld worldIn) {
         this.worldRenderer.setWorldAndLoadRenderers(worldIn);
         this.particles.clearEffects(worldIn);
         TileEntityRendererDispatcher.instance.setWorld(worldIn);
         this.setDefaultMinecraftTitle();
+        //Forge
+        Reflector.call(Reflector.MinecraftForgeClient_clearRenderCache);
+        //
     }
 
-    public boolean isMultiplayerEnabled()
-    {
+    public boolean isMultiplayerEnabled() {
         return this.enableMultiplayer && this.field_244734_au.serversAllowed();
     }
 
-    public boolean cannotSendChatMessages(UUID playerUUID)
-    {
-        if (this.isChatEnabled())
-        {
+    public boolean cannotSendChatMessages(UUID playerUUID) {
+        if (this.isChatEnabled()) {
             return this.field_244597_aC.func_244756_c(playerUUID);
-        }
-        else
-        {
+        } else {
             return (this.player == null || !playerUUID.equals(this.player.getUniqueID())) && !playerUUID.equals(Util.DUMMY_UUID);
         }
     }
 
-    public boolean isChatEnabled()
-    {
+    public boolean isChatEnabled() {
         return this.enableChat && this.field_244734_au.chatAllowed();
     }
 
     /**
      * Gets whether this is a demo or not.
      */
-    public final boolean isDemo()
-    {
+    public final boolean isDemo() {
         return this.isDemo;
     }
 
     @Nullable
-    public ClientPlayNetHandler getConnection()
-    {
+    public ClientPlayNetHandler getConnection() {
         return this.player == null ? null : this.player.connection;
     }
 
-    public static boolean isGuiEnabled()
-    {
-        return !instance.gameSettings.hideGUI;
-    }
-
-    public static boolean isFancyGraphicsEnabled()
-    {
-        return instance.gameSettings.graphicFanciness.func_238162_a_() >= GraphicsFanciness.FANCY.func_238162_a_();
-    }
-
-    public static boolean isFabulousGraphicsEnabled()
-    {
-        return instance.gameSettings.graphicFanciness.func_238162_a_() >= GraphicsFanciness.FABULOUS.func_238162_a_();
-    }
-
-    /**
-     * Returns if ambient occlusion is enabled
-     */
-    public static boolean isAmbientOcclusionEnabled()
-    {
-        return instance.gameSettings.ambientOcclusionStatus != AmbientOcclusionStatus.OFF;
-    }
-
     /**
      * Called when user clicked he's mouse middle button (pick block)
      */
-    private void middleClickMouse()
-    {
-        if (this.objectMouseOver != null && this.objectMouseOver.getType() != RayTraceResult.Type.MISS)
-        {
+    private void middleClickMouse() {
+        if (this.objectMouseOver != null && this.objectMouseOver.getType() != RayTraceResult.Type.MISS) {
+
+            Object inputEvent;
+            inputEvent = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 2, this.gameSettings.keyBindPickBlock, Hand.MAIN_HAND);
+
+            //Forge
+            if (inputEvent != null && !Reflector.callBoolean(inputEvent, Reflector.Event_isCanceled))
+                Reflector.call(Reflector.ForgeHooks_onPickBlock, this.objectMouseOver, this.player, this.world);
+            if (inputEvent != null) return;
+            //
+
             boolean flag = this.player.abilities.isCreativeMode;
             TileEntity tileentity = null;
             RayTraceResult.Type raytraceresult$type = this.objectMouseOver.getType();
             ItemStack itemstack;
 
-            if (raytraceresult$type == RayTraceResult.Type.BLOCK)
-            {
-                BlockPos blockpos = ((BlockRayTraceResult)this.objectMouseOver).getPos();
+            if (raytraceresult$type == RayTraceResult.Type.BLOCK) {
+                BlockPos blockpos = ((BlockRayTraceResult) this.objectMouseOver).getPos();
                 BlockState blockstate = this.world.getBlockState(blockpos);
                 Block block = blockstate.getBlock();
 
-                if (blockstate.isAir())
-                {
+                if (blockstate.isAir()) {
                     return;
                 }
 
                 itemstack = block.getItem(this.world, blockpos, blockstate);
 
-                if (itemstack.isEmpty())
-                {
+                if (itemstack.isEmpty()) {
                     return;
                 }
 
-                if (flag && Screen.hasControlDown() && block.isTileEntityProvider())
-                {
+                if (flag && Screen.hasControlDown() && block.isTileEntityProvider()) {
                     tileentity = this.world.getTileEntity(blockpos);
                 }
-            }
-            else
-            {
-                if (raytraceresult$type != RayTraceResult.Type.ENTITY || !flag)
-                {
+            } else {
+                if (raytraceresult$type != RayTraceResult.Type.ENTITY || !flag) {
                     return;
                 }
 
-                Entity entity = ((EntityRayTraceResult)this.objectMouseOver).getEntity();
+                Entity entity = ((EntityRayTraceResult) this.objectMouseOver).getEntity();
 
-                if (entity instanceof PaintingEntity)
-                {
+                if (entity instanceof PaintingEntity) {
                     itemstack = new ItemStack(Items.PAINTING);
-                }
-                else if (entity instanceof LeashKnotEntity)
-                {
+                } else if (entity instanceof LeashKnotEntity) {
                     itemstack = new ItemStack(Items.LEAD);
-                }
-                else if (entity instanceof ItemFrameEntity)
-                {
-                    ItemFrameEntity itemframeentity = (ItemFrameEntity)entity;
+                } else if (entity instanceof ItemFrameEntity) {
+                    ItemFrameEntity itemframeentity = (ItemFrameEntity) entity;
                     ItemStack itemstack1 = itemframeentity.getDisplayedItem();
 
-                    if (itemstack1.isEmpty())
-                    {
+                    if (itemstack1.isEmpty()) {
                         itemstack = new ItemStack(Items.ITEM_FRAME);
-                    }
-                    else
-                    {
+                    } else {
                         itemstack = itemstack1.copy();
                     }
-                }
-                else if (entity instanceof AbstractMinecartEntity)
-                {
-                    AbstractMinecartEntity abstractminecartentity = (AbstractMinecartEntity)entity;
+                } else if (entity instanceof AbstractMinecartEntity) {
+                    AbstractMinecartEntity abstractminecartentity = (AbstractMinecartEntity) entity;
                     Item item;
 
-                    switch (abstractminecartentity.getMinecartType())
-                    {
+                    switch (abstractminecartentity.getMinecartType()) {
                         case FURNACE:
                             item = Items.FURNACE_MINECART;
                             break;
@@ -2556,25 +2694,16 @@
                     }
 
                     itemstack = new ItemStack(item);
-                }
-                else if (entity instanceof BoatEntity)
-                {
-                    itemstack = new ItemStack(((BoatEntity)entity).getItemBoat());
-                }
-                else if (entity instanceof ArmorStandEntity)
-                {
+                } else if (entity instanceof BoatEntity) {
+                    itemstack = new ItemStack(((BoatEntity) entity).getItemBoat());
+                } else if (entity instanceof ArmorStandEntity) {
                     itemstack = new ItemStack(Items.ARMOR_STAND);
-                }
-                else if (entity instanceof EnderCrystalEntity)
-                {
+                } else if (entity instanceof EnderCrystalEntity) {
                     itemstack = new ItemStack(Items.END_CRYSTAL);
-                }
-                else
-                {
+                } else {
                     SpawnEggItem spawneggitem = SpawnEggItem.getEgg(entity.getType());
 
-                    if (spawneggitem == null)
-                    {
+                    if (spawneggitem == null) {
                         return;
                     }
 
@@ -2582,182 +2711,77 @@
                 }
             }
 
-            if (itemstack.isEmpty())
-            {
+            if (itemstack.isEmpty()) {
                 String s = "";
 
-                if (raytraceresult$type == RayTraceResult.Type.BLOCK)
-                {
-                    s = Registry.BLOCK.getKey(this.world.getBlockState(((BlockRayTraceResult)this.objectMouseOver).getPos()).getBlock()).toString();
-                }
-                else if (raytraceresult$type == RayTraceResult.Type.ENTITY)
-                {
-                    s = Registry.ENTITY_TYPE.getKey(((EntityRayTraceResult)this.objectMouseOver).getEntity().getType()).toString();
+                if (raytraceresult$type == RayTraceResult.Type.BLOCK) {
+                    s = Registry.BLOCK.getKey(this.world.getBlockState(((BlockRayTraceResult) this.objectMouseOver).getPos()).getBlock()).toString();
+                } else if (raytraceresult$type == RayTraceResult.Type.ENTITY) {
+                    s = Registry.ENTITY_TYPE.getKey(((EntityRayTraceResult) this.objectMouseOver).getEntity().getType()).toString();
                 }
 
                 LOGGER.warn("Picking on: [{}] {} gave null item", raytraceresult$type, s);
-            }
-            else
-            {
+            } else {
                 PlayerInventory playerinventory = this.player.inventory;
 
-                if (tileentity != null)
-                {
+                if (tileentity != null) {
                     this.storeTEInStack(itemstack, tileentity);
                 }
 
                 int i = playerinventory.getSlotFor(itemstack);
 
-                if (flag)
-                {
+                if (flag) {
                     playerinventory.setPickedItemStack(itemstack);
                     this.playerController.sendSlotPacket(this.player.getHeldItem(Hand.MAIN_HAND), 36 + playerinventory.currentItem);
-                }
-                else if (i != -1)
-                {
-                    if (PlayerInventory.isHotbar(i))
-                    {
+                } else if (i != -1) {
+                    if (PlayerInventory.isHotbar(i)) {
                         playerinventory.currentItem = i;
-                    }
-                    else
-                    {
+                    } else {
                         this.playerController.pickItem(i);
-                    }
-                }
-            }
-        }
-    }
-
-    private ItemStack storeTEInStack(ItemStack stack, TileEntity te)
-    {
-        CompoundNBT compoundnbt = te.write(new CompoundNBT());
-
-        if (stack.getItem() instanceof SkullItem && compoundnbt.contains("SkullOwner"))
-        {
-            CompoundNBT compoundnbt2 = compoundnbt.getCompound("SkullOwner");
-            stack.getOrCreateTag().put("SkullOwner", compoundnbt2);
-            return stack;
-        }
-        else
-        {
-            stack.setTagInfo("BlockEntityTag", compoundnbt);
-            CompoundNBT compoundnbt1 = new CompoundNBT();
-            ListNBT listnbt = new ListNBT();
-            listnbt.add(StringNBT.valueOf("\"(+NBT)\""));
-            compoundnbt1.put("Lore", listnbt);
-            stack.setTagInfo("display", compoundnbt1);
-            return stack;
-        }
-    }
-
-    /**
-     * adds core server Info (GL version , Texture pack, isModded, type), and the worldInfo to the crash report
-     */
-    public CrashReport addGraphicsAndWorldToCrashReport(CrashReport theCrash)
-    {
-        fillCrashReport(this.languageManager, this.launchedVersion, this.gameSettings, theCrash);
-
-        if (this.world != null)
-        {
-            this.world.fillCrashReport(theCrash);
-        }
-
-        return theCrash;
-    }
-
-    public static void fillCrashReport(@Nullable LanguageManager languageManagerIn, String versionIn, @Nullable GameSettings settingsIn, CrashReport crashReportIn)
-    {
-        CrashReportCategory crashreportcategory = crashReportIn.getCategory();
-        crashreportcategory.addDetail("Launched Version", () ->
-        {
-            return versionIn;
-        });
-        crashreportcategory.addDetail("Backend library", RenderSystem::getBackendDescription);
-        crashreportcategory.addDetail("Backend API", RenderSystem::getApiDescription);
-        crashreportcategory.addDetail("GL Caps", RenderSystem::getCapsString);
-        crashreportcategory.addDetail("Using VBOs", () ->
-        {
-            return "Yes";
-        });
-        crashreportcategory.addDetail("Is Modded", () ->
-        {
-            String s1 = ClientBrandRetriever.getClientModName();
-
-            if (!"vanilla".equals(s1))
-            {
-                return "Definitely; Client brand changed to '" + s1 + "'";
-            }
-            else {
-                return Minecraft.class.getSigners() == null ? "Very likely; Jar signature invalidated" : "Probably not. Jar signature remains and client brand is untouched.";
-            }
-        });
-        crashreportcategory.addDetail("Type", "Client (map_client.txt)");
-
-        if (settingsIn != null)
-        {
-            if (instance != null)
-            {
-                String s = instance.getGPUWarning().func_243499_m();
-
-                if (s != null)
-                {
-                    crashreportcategory.addDetail("GPU Warnings", s);
-                }
-            }
-
-            crashreportcategory.addDetail("Graphics mode", settingsIn.graphicFanciness);
-            crashreportcategory.addDetail("Resource Packs", () ->
-            {
-                StringBuilder stringbuilder = new StringBuilder();
-
-                for (String s1 : settingsIn.resourcePacks)
-                {
-                    if (stringbuilder.length() > 0)
-                    {
-                        stringbuilder.append(", ");
-                    }
-
-                    stringbuilder.append(s1);
-
-                    if (settingsIn.incompatibleResourcePacks.contains(s1))
-                    {
-                        stringbuilder.append(" (incompatible)");
-                    }
-                }
-
-                return stringbuilder.toString();
-            });
-        }
-
-        if (languageManagerIn != null)
-        {
-            crashreportcategory.addDetail("Current Language", () ->
-            {
-                return languageManagerIn.getCurrentLanguage().toString();
-            });
+                    }
+                }
+            }
         }
 
-        crashreportcategory.addDetail("CPU", PlatformDescriptors::getCpuInfo);
+        physicalGuiManager.init(player);
+    }
+
+    private ItemStack storeTEInStack(ItemStack stack, TileEntity te) {
+        CompoundNBT compoundnbt = te.write(new CompoundNBT());
+
+        if (stack.getItem() instanceof SkullItem && compoundnbt.contains("SkullOwner")) {
+            CompoundNBT compoundnbt2 = compoundnbt.getCompound("SkullOwner");
+            stack.getOrCreateTag().put("SkullOwner", compoundnbt2);
+        } else {
+            stack.setTagInfo("BlockEntityTag", compoundnbt);
+            CompoundNBT compoundnbt1 = new CompoundNBT();
+            ListNBT listnbt = new ListNBT();
+            listnbt.add(StringNBT.valueOf("\"(+NBT)\""));
+            compoundnbt1.put("Lore", listnbt);
+            stack.setTagInfo("display", compoundnbt1);
+        }
+        return stack;
     }
 
     /**
-     * Return the singleton Minecraft instance for the game
+     * adds core server Info (GL version , Texture pack, isModded, type), and the worldInfo to the crash report
      */
-    public static Minecraft getInstance()
-    {
-        return instance;
+    public CrashReport addGraphicsAndWorldToCrashReport(CrashReport theCrash) {
+        fillCrashReport(this.languageManager, this.launchedVersion, this.gameSettings, theCrash);
+
+        if (this.world != null) {
+            this.world.fillCrashReport(theCrash);
+        }
+
+        return theCrash;
     }
 
-    public CompletableFuture<Void> scheduleResourcesRefresh()
-    {
+    public CompletableFuture<Void> scheduleResourcesRefresh() {
         return this.supplyAsync(this::reloadResources).thenCompose((voidIn) ->
-        {
-            return voidIn;
-        });
+                voidIn);
     }
 
-    public void fillSnooper(Snooper snooper)
-    {
+    public void fillSnooper(Snooper snooper) {
         snooper.addClientStat("fps", debugFPS);
         snooper.addClientStat("vsync_enabled", this.gameSettings.vsync);
         snooper.addClientStat("display_frequency", this.mainWindow.getRefreshRate());
@@ -2771,18 +2795,15 @@
         snooper.addClientStat("touch", this.gameSettings.touchscreen ? "touch" : "mouse");
         int i = 0;
 
-        for (ResourcePackInfo resourcepackinfo : this.resourcePackRepository.getEnabledPacks())
-        {
-            if (!resourcepackinfo.isAlwaysEnabled() && !resourcepackinfo.isOrderLocked())
-            {
+        for (ResourcePackInfo resourcepackinfo : this.resourcePackRepository.getEnabledPacks()) {
+            if (!resourcepackinfo.isAlwaysEnabled() && !resourcepackinfo.isOrderLocked()) {
                 snooper.addClientStat("resource_pack[" + i++ + "]", resourcepackinfo.getName());
             }
         }
 
         snooper.addClientStat("resource_packs", i);
 
-        if (this.integratedServer != null)
-        {
+        if (this.integratedServer != null) {
             snooper.addClientStat("snooper_partner", this.integratedServer.getSnooper().getUniqueID());
         }
     }
@@ -2790,18 +2811,12 @@
     /**
      * Return the current action's name
      */
-    private String getCurrentAction()
-    {
-        if (this.integratedServer != null)
-        {
+    private String getCurrentAction() {
+        if (this.integratedServer != null) {
             return this.integratedServer.getPublic() ? "hosting_lan" : "singleplayer";
-        }
-        else if (this.currentServerData != null)
-        {
+        } else if (this.currentServerData != null) {
             return this.currentServerData.isOnLAN() ? "playing_lan" : "multiplayer";
-        }
-        else
-        {
+        } else {
             return "out_of_game";
         }
     }
@@ -2809,27 +2824,23 @@
     /**
      * Set the current ServerData instance.
      */
-    public void setServerData(@Nullable ServerData serverDataIn)
-    {
+    public void setServerData(@Nullable ServerData serverDataIn) {
         this.currentServerData = serverDataIn;
     }
 
     @Nullable
-    public ServerData getCurrentServerData()
-    {
+    public ServerData getCurrentServerData() {
         return this.currentServerData;
     }
 
-    public boolean isIntegratedServerRunning()
-    {
+    public boolean isIntegratedServerRunning() {
         return this.integratedServerIsRunning;
     }
 
     /**
      * Returns true if there is only one player playing, and the current server is the integrated one.
      */
-    public boolean isSingleplayer()
-    {
+    public boolean isSingleplayer() {
         return this.integratedServerIsRunning && this.integratedServer != null;
     }
 
@@ -2838,31 +2849,26 @@
     /**
      * Returns the currently running integrated server
      */
-    public IntegratedServer getIntegratedServer()
-    {
+    public IntegratedServer getIntegratedServer() {
         return this.integratedServer;
     }
 
     /**
      * Returns the PlayerUsageSnooper instance.
      */
-    public Snooper getSnooper()
-    {
+    public Snooper getSnooper() {
         return this.snooper;
     }
 
-    public Session getSession()
-    {
+    public Session getSession() {
         return this.session;
     }
 
     /**
      * Return the player's GameProfile properties
      */
-    public PropertyMap getProfileProperties()
-    {
-        if (this.profileProperties.isEmpty())
-        {
+    public PropertyMap getProfileProperties() {
+        if (this.profileProperties.isEmpty()) {
             GameProfile gameprofile = this.getSessionService().fillProfileProperties(this.session.getProfile(), false);
             this.profileProperties.putAll(gameprofile.getProperties());
         }
@@ -2870,382 +2876,779 @@
         return this.profileProperties;
     }
 
-    public Proxy getProxy()
-    {
+    public Proxy getProxy() {
         return this.proxy;
     }
 
-    public TextureManager getTextureManager()
-    {
+    public TextureManager getTextureManager() {
         return this.textureManager;
     }
 
-    public IResourceManager getResourceManager()
-    {
+    public IResourceManager getResourceManager() {
         return this.resourceManager;
     }
 
-    public ResourcePackList getResourcePackList()
-    {
+    public ResourcePackList getResourcePackList() {
         return this.resourcePackRepository;
     }
 
-    public DownloadingPackFinder getPackFinder()
-    {
+    public DownloadingPackFinder getPackFinder() {
         return this.packFinder;
     }
 
-    public File getFileResourcePacks()
-    {
+    public File getFileResourcePacks() {
         return this.fileResourcepacks;
     }
 
-    public LanguageManager getLanguageManager()
-    {
+    public LanguageManager getLanguageManager() {
         return this.languageManager;
     }
 
-    public Function<ResourceLocation, TextureAtlasSprite> getAtlasSpriteGetter(ResourceLocation locationIn)
-    {
+    public Function<ResourceLocation, TextureAtlasSprite> getAtlasSpriteGetter(ResourceLocation locationIn) {
         return this.modelManager.getAtlasTexture(locationIn)::getSprite;
     }
 
-    public boolean isJava64bit()
-    {
+    public boolean isJava64bit() {
         return this.jvm64bit;
     }
 
-    public boolean isGamePaused()
-    {
+    public boolean isGamePaused() {
         return this.isGamePaused;
     }
 
-    public GPUWarning getGPUWarning()
-    {
+    public GPUWarning getGPUWarning() {
         return this.warningGPU;
     }
 
-    public SoundHandler getSoundHandler()
-    {
+    public SoundHandler getSoundHandler() {
         return this.soundHandler;
     }
 
-    public BackgroundMusicSelector getBackgroundMusicSelector()
-    {
-        if (this.currentScreen instanceof WinGameScreen)
-        {
+    public BackgroundMusicSelector getBackgroundMusicSelector() {
+        if (this.currentScreen instanceof WinGameScreen) {
             return BackgroundMusicTracks.CREDITS_MUSIC;
-        }
-        else if (this.player != null)
-        {
-            if (this.player.world.getDimensionKey() == World.THE_END)
-            {
+        } else if (this.player != null) {
+            if (this.player.world.getDimensionKey() == World.THE_END) {
                 return this.ingameGUI.getBossOverlay().shouldPlayEndBossMusic() ? BackgroundMusicTracks.DRAGON_FIGHT_MUSIC : BackgroundMusicTracks.END_MUSIC;
-            }
-            else
-            {
+            } else {
                 Biome.Category biome$category = this.player.world.getBiome(this.player.getPosition()).getCategory();
 
-                if (!this.musicTicker.isBackgroundMusicPlaying(BackgroundMusicTracks.UNDER_WATER_MUSIC) && (!this.player.canSwim() || biome$category != Biome.Category.OCEAN && biome$category != Biome.Category.RIVER))
-                {
+                if (!this.musicTicker.isBackgroundMusicPlaying(BackgroundMusicTracks.UNDER_WATER_MUSIC) && (!this.player.canSwim() || biome$category != Biome.Category.OCEAN && biome$category != Biome.Category.RIVER)) {
                     return this.player.world.getDimensionKey() != World.THE_NETHER && this.player.abilities.isCreativeMode && this.player.abilities.allowFlying ? BackgroundMusicTracks.CREATIVE_MODE_MUSIC : this.world.getBiomeManager().getBiomeAtPosition(this.player.getPosition()).getBackgroundMusic().orElse(BackgroundMusicTracks.WORLD_MUSIC);
-                }
-                else
-                {
+                } else {
                     return BackgroundMusicTracks.UNDER_WATER_MUSIC;
                 }
             }
-        }
-        else
-        {
+        } else {
             return BackgroundMusicTracks.MAIN_MENU_MUSIC;
         }
     }
 
-    public MinecraftSessionService getSessionService()
-    {
+    public MinecraftSessionService getSessionService() {
         return this.sessionService;
     }
 
-    public SkinManager getSkinManager()
-    {
+    public SkinManager getSkinManager() {
         return this.skinManager;
     }
 
     @Nullable
-    public Entity getRenderViewEntity()
-    {
+    public Entity getRenderViewEntity() {
         return this.renderViewEntity;
     }
 
-    public void setRenderViewEntity(Entity viewingEntity)
-    {
+    public void setRenderViewEntity(Entity viewingEntity) {
         this.renderViewEntity = viewingEntity;
         this.gameRenderer.loadEntityShader(viewingEntity);
     }
 
-    public boolean isEntityGlowing(Entity entity)
-    {
+    public boolean isEntityGlowing(Entity entity) {
         return entity.isGlowing() || this.player != null && this.player.isSpectator() && this.gameSettings.keyBindSpectatorOutlines.isKeyDown() && entity.getType() == EntityType.PLAYER;
     }
 
-    protected Thread getExecutionThread()
-    {
+    protected Thread getExecutionThread() {
         return this.thread;
     }
 
-    protected Runnable wrapTask(Runnable runnable)
-    {
+    protected Runnable wrapTask(Runnable runnable) {
         return runnable;
     }
 
-    protected boolean canRun(Runnable runnable)
-    {
+    protected boolean canRun(Runnable runnable) {
         return true;
     }
 
-    public BlockRendererDispatcher getBlockRendererDispatcher()
-    {
+    public BlockRendererDispatcher getBlockRendererDispatcher() {
         return this.blockRenderDispatcher;
     }
 
-    public EntityRendererManager getRenderManager()
-    {
+    public EntityRendererManager getRenderManager() {
         return this.renderManager;
     }
 
-    public ItemRenderer getItemRenderer()
-    {
+    public ItemRenderer getItemRenderer() {
         return this.itemRenderer;
     }
 
-    public FirstPersonRenderer getFirstPersonRenderer()
-    {
+    public FirstPersonRenderer getFirstPersonRenderer() {
         return this.firstPersonRenderer;
     }
 
-    public <T> IMutableSearchTree<T> getSearchTree(SearchTreeManager.Key<T> key)
-    {
+    public <T> IMutableSearchTree<T> getSearchTree(SearchTreeManager.Key<T> key) {
         return this.searchTreeManager.get(key);
     }
 
     /**
      * Return the FrameTimer's instance
      */
-    public FrameTimer getFrameTimer()
-    {
+    public FrameTimer getFrameTimer() {
         return this.frameTimer;
     }
 
     /**
      * Return true if the player is connected to a realms server
      */
-    public boolean isConnectedToRealms()
-    {
+    public boolean isConnectedToRealms() {
         return this.connectedToRealms;
     }
 
     /**
      * Set if the player is connected to a realms server
      */
-    public void setConnectedToRealms(boolean isConnected)
-    {
+    public void setConnectedToRealms(boolean isConnected) {
         this.connectedToRealms = isConnected;
     }
 
-    public DataFixer getDataFixer()
-    {
+    public DataFixer getDataFixer() {
         return this.dataFixer;
     }
 
-    public float getRenderPartialTicks()
-    {
+    public float getRenderPartialTicks() {
         return this.timer.renderPartialTicks;
     }
 
-    public float getTickLength()
-    {
+    public float getTickLength() {
         return this.timer.elapsedPartialTicks;
     }
 
-    public BlockColors getBlockColors()
-    {
+    public BlockColors getBlockColors() {
         return this.blockColors;
     }
 
     /**
      * Whether to use reduced debug info
      */
-    public boolean isReducedDebug()
-    {
+    public boolean isReducedDebug() {
         return this.player != null && this.player.hasReducedDebug() || this.gameSettings.reducedDebugInfo;
     }
 
-    public ToastGui getToastGui()
-    {
+    public ToastGui getToastGui() {
         return this.toastGui;
     }
 
-    public Tutorial getTutorial()
-    {
+    public Tutorial getTutorial() {
         return this.tutorial;
     }
 
-    public boolean isGameFocused()
-    {
+    public boolean isGameFocused() {
         return this.isWindowFocused;
     }
 
-    public CreativeSettings getCreativeSettings()
-    {
+    public void setGameFocused(boolean focused) {
+        this.isWindowFocused = focused;
+    }
+
+    public CreativeSettings getCreativeSettings() {
         return this.creativeSettings;
     }
 
-    public ModelManager getModelManager()
-    {
+    public ModelManager getModelManager() {
         return this.modelManager;
     }
 
     /**
      * Gets the sprite uploader used for paintings.
      */
-    public PaintingSpriteUploader getPaintingSpriteUploader()
-    {
+    public PaintingSpriteUploader getPaintingSpriteUploader() {
         return this.paintingSprites;
     }
 
     /**
      * Gets the sprite uploader used for potions.
      */
-    public PotionSpriteUploader getPotionSpriteUploader()
-    {
+    public PotionSpriteUploader getPotionSpriteUploader() {
         return this.potionSprites;
     }
 
-    public void setGameFocused(boolean focused)
-    {
-        this.isWindowFocused = focused;
-    }
-
-    public IProfiler getProfiler()
-    {
+    public IProfiler getProfiler() {
         return this.profiler;
     }
 
-    public MinecraftGame getMinecraftGame()
-    {
+    public MinecraftGame getMinecraftGame() {
         return this.game;
     }
 
-    public Splashes getSplashes()
-    {
+    public Splashes getSplashes() {
         return this.splashes;
     }
 
     @Nullable
-    public LoadingGui getLoadingGui()
-    {
+    public LoadingGui getLoadingGui() {
         return this.loadingGui;
     }
 
-    public FilterManager func_244599_aA()
-    {
+    // VIVECRAFT ADDITIONS
+    // **************************************************************************
+
+    public void setLoadingGui(@Nullable LoadingGui loadingGuiIn) {
+        this.loadingGui = loadingGuiIn;
+    }
+
+    public FilterManager func_244599_aA() {
         return this.field_244597_aC;
     }
 
-    public boolean isRenderOnThread()
-    {
+    public boolean isRenderOnThread() {
         return false;
     }
 
-    public MainWindow getMainWindow()
-    {
+    public MainWindow getMainWindow() {
         return this.mainWindow;
     }
 
-    public RenderTypeBuffers getRenderTypeBuffers()
-    {
+    public RenderTypeBuffers getRenderTypeBuffers() {
         return this.renderTypeBuffers;
     }
 
-    private static ResourcePackInfo makePackInfo(String name, boolean isAlwaysEnabled, Supplier<IResourcePack> resourceSupplier, IResourcePack resourcePack, PackMetadataSection resourcePackMeta, ResourcePackInfo.Priority priority, IPackNameDecorator decorator)
-    {
-        int i = resourcePackMeta.getPackFormat();
-        Supplier<IResourcePack> supplier = resourceSupplier;
+    public void setMipmapLevels(int mipMapLevel) {
+        this.modelManager.setMaxMipmapLevel(mipMapLevel);
+    }
 
-        if (i <= 3)
-        {
-            supplier = wrapV3(resourceSupplier);
+    public void printChatMessage(String msg) {
+        if (this.world != null) {
+            ITextComponent chatText = new StringTextComponent(msg);
+            this.ingameGUI.getChatGUI().printChatMessage(chatText);
+        }
+    }
+
+    public void printGLMatrix(String derp) {
+        GL11.glGetFloatv(GL11.GL_MODELVIEW_MATRIX, matrixBuffer);
+        matrixBuffer.rewind();
+        Matrix4f temp = new Matrix4f();
+        temp.load(matrixBuffer);
+        System.out.println(derp + "\r\n" + temp.toString());
+        matrixBuffer.rewind();
+    }
+
+    public void clearGLError() // bad bad bad
+    {
+        int var2 = GL11.glGetError();
+    }
+
+    private void copyToMirror() {
+        // VIVE start - render eye buffers to the desktop window
+
+        if (this.vrSettings.displayMirrorMode < VRSettings.MIRROR_OFF) // new values
+            this.vrSettings.displayMirrorMode = VRSettings.MIRROR_ON_CROPPED;
+
+        if (this.vrSettings.displayMirrorMode > VRSettings.MIRROR_ON_CROPPED) // new values
+            this.vrSettings.displayMirrorMode = VRSettings.MIRROR_ON_CROPPED;
+
+        if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_OFF && MCOpenVR.isHMDTracking()) {
+            notifyMirror("Mirror is OFF", true, 1000);
+        } else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY) {
+            if (VRShaders._DepthMask_shaderProgramId != 0) {
+                doMixedRealityMirror();
+            } else {
+                notifyMirror("Shader compile failed, see log", true, 10000);
+            }
+        } else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_ON_DUAL) {
+            Framebuffer source = stereoProvider.framebufferEye0;
+            Framebuffer source2 = stereoProvider.framebufferEye1;
+
+            //debug
+            //source2 = worldRenderer.func_239229_r_(); //Particles
+            //source2 = stereoProvider.telescopeFramebufferR;
+
+            if (source != null)
+                source.framebufferRenderExt(0,
+                        mainWindow.getWidth() / 2, mainWindow.getHeight(), 0, true, 0, 0, false);
+
+            if (source2 != null)
+                source2.framebufferRenderExt((mainWindow.getWidth() / 2),
+                        mainWindow.getWidth() / 2, mainWindow.getHeight(), 0, true, 0, 0, false);
+
+        } else {
+            float xcrop = 0;
+            float ycrop = 0;
+            boolean ar = false;
+            Framebuffer source = stereoProvider.framebufferEye0;
+            if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_FIRST_PERSON) {
+                source = stereoProvider.framebufferUndistorted;
+            } else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_THIRD_PERSON) {
+                source = stereoProvider.framebufferMR;
+            } else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_ON_SINGLE || this.vrSettings.displayMirrorMode == VRSettings.MIRROR_OFF) {
+                if (!this.vrSettings.displayMirrorLeftEye)
+                    source = stereoProvider.framebufferEye1;
+            } else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_ON_CROPPED) {
+                if (!this.vrSettings.displayMirrorLeftEye)
+                    source = stereoProvider.framebufferEye1;
+                xcrop = 0.15f;
+                ycrop = 0.15f;
+                ar = true;
+            }
+            //debug
+            //	source = GuiHandler.guiFramebuffer;
+            //	source = stereoProvider.framebufferEye0;
+            //	source = stereoProvider.framebufferEye1;
+            //	source = GuiHandler.guiFramebuffer;
+            //source = worldRenderer.func_239228_q_(); //water
+            //source = worldRenderer.func_239229_r_(); //entity glint
+            //source = worldRenderer.func_239232_u_(); //Clouds
+            //source = worldRenderer.func_239230_s_(); //Particles
+            //source = stereoProvider.telescopeFramebufferR;
+
+            if (source != null)
+                source.framebufferRenderExt(0, mainWindow.getWidth(), mainWindow.getHeight(), 0, true, xcrop, ycrop, ar);
+        }
+    }
+
+    private void doMixedRealityMirror() {
+        boolean hasShaders = Config.isShaders();
+        boolean alphaMask = this.vrSettings.mixedRealityUnityLike && this.vrSettings.mixedRealityAlphaMask;
+
+        if (!alphaMask)
+            GlStateManager.clearColor(vrSettings.mixedRealityKeyColor.getRed() / 255F,
+                    vrSettings.mixedRealityKeyColor.getGreen() / 255F, vrSettings.mixedRealityKeyColor.getBlue() / 255F,
+                    1);
+        else
+            GlStateManager.clearColor(0, 0, 0, 1);
+
+        GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+
+        Vector3d camplayer = vrPlayer.vrdata_room_pre.getHeadPivot().subtract(vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getPosition());
+
+        net.minecraft.util.math.vector.Matrix4f viewMatrix = vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getMatrix().transposed().toMCMatrix();
+        Vector3 CameraLook = vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getMatrix().transform(Vector3.forward());
+
+        GlStateManager.useProgram(VRShaders._DepthMask_shaderProgramId);
+
+        // set projection matrix
+        gameRenderer.thirdPassProjectionMatrix.write(matrixBuffer);
+        matrixBuffer.rewind();
+        ARBShaderObjects.glUniformMatrix4fvARB(VRShaders._DepthMask_projectionMatrix, false, matrixBuffer);
+
+        // set view matrix
+        viewMatrix.write(matrixBuffer);
+        matrixBuffer.rewind();
+        ARBShaderObjects.glUniformMatrix4fvARB(VRShaders._DepthMask_viewMatrix, false, matrixBuffer);
+
+        ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_colorTexUniform, 1);
+        ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_depthTexUniform, 2);
+        ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdViewPosition, (float) camplayer.x, (float) camplayer.y,
+                (float) camplayer.z);
+        ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdPlaneNormal, -CameraLook.getX(), 0,
+                -CameraLook.getZ());
+        ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_keyColorUniform,
+                vrSettings.mixedRealityKeyColor.getRed() / 255F, vrSettings.mixedRealityKeyColor.getGreen() / 255F,
+                vrSettings.mixedRealityKeyColor.getBlue() / 255F);
+        ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_alphaModeUniform, alphaMask ? 1 : 0);
+
+        // bind color and depth textures
+        GlStateManager.activeTexture(GL13.GL_TEXTURE1);
+        stereoProvider.framebufferMR.bindFramebufferTexture();
+
+        GlStateManager.activeTexture(GL13.GL_TEXTURE2);
+        if (hasShaders)
+            GlStateManager.bindTexture(Shaders.dfbDepthTextures.get(0)); // shadersmod has it's own depth buffer
+        else
+            GlStateManager.bindTexture(stereoProvider.framebufferMR.depthBuffer);
+
+        GlStateManager.activeTexture(GL13.GL_TEXTURE0);
+
+        for (int i = 0; i < (alphaMask ? 3 : 2); i++) {
+
+            int resW = mainWindow.getWidth() / 2;
+            int resH = mainWindow.getHeight();
+            int posW = (mainWindow.getWidth() / 2) * i;
+            int posH = 0;
+
+            if (this.vrSettings.mixedRealityUnityLike) {
+                resW = mainWindow.getWidth() / 2;
+                resH = mainWindow.getHeight() / 2;
+                if (this.vrSettings.mixedRealityAlphaMask && i == 2) {
+                    posW = mainWindow.getWidth() / 2;
+                    posH = mainWindow.getHeight() / 2;
+                } else {
+                    posW = 0;
+                    posH = (mainWindow.getHeight() / 2) * (1 - i);
+                }
+            }
+
+            // set other uniforms
+            ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_resolutionUniform, resW, resH);
+            ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_positionUniform, posW, posH);
+            ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_passUniform, i);
+
+            // draw framebuffer
+            stereoProvider.framebufferMR.framebufferRenderExt(posW, resW, resH, posH, true, 0, 0, false);
         }
 
-        if (i <= 4)
-        {
-            supplier = wrapV4(supplier);
+        GlStateManager.useProgram(0);
+
+        if (this.vrSettings.mixedRealityUnityLike) {
+            if (this.vrSettings.mixedRealityMRPlusUndistorted)
+                stereoProvider.framebufferUndistorted.framebufferRenderExt(mainWindow.getWidth() / 2,
+                        mainWindow.getWidth() / 2, mainWindow.getHeight() / 2, 0, true, 0, 0, false);
+            else
+                stereoProvider.framebufferEye0.framebufferRenderExt(mainWindow.getWidth() / 2,
+                        mainWindow.getWidth() / 2, mainWindow.getHeight() / 2, 0, true, 0, 0, false);
         }
 
-        return new ResourcePackInfo(name, isAlwaysEnabled, supplier, resourcePack, resourcePackMeta, priority, decorator);
     }
 
-    private static Supplier<IResourcePack> wrapV3(Supplier<IResourcePack> resourcePackSupplier)
-    {
-        return () ->
-        {
-            return new LegacyResourcePackWrapper(resourcePackSupplier.get(), LegacyResourcePackWrapper.NEW_TO_LEGACY_MAP);
-        };
+    private void checkGLError(String message) {
+        Config.checkGlError(message);
     }
 
-    private static Supplier<IResourcePack> wrapV4(Supplier<IResourcePack> resourcePackSupplier)
-    {
-        return () ->
-        {
-            return new LegacyResourcePackWrapperV4(resourcePackSupplier.get());
-        };
+    public void initMinecrift() throws Exception {
+        new MCOpenVR();
+        MCOpenVR.init();
+        this.stereoProvider = new OpenVRStereoRenderer();
+
+        this.vrPlayer = new OpenVRPlayer();
+
+        stereoProvider.lastGuiScale = this.gameSettings.guiScale;
+
+        // register Trackers
+        vrPlayer.registerTracker(backpackTracker);
+        vrPlayer.registerTracker(bowTracker);
+        vrPlayer.registerTracker(climbTracker);
+        vrPlayer.registerTracker(autoFood);
+        vrPlayer.registerTracker(jumpTracker);
+        vrPlayer.registerTracker(rowTracker);
+        vrPlayer.registerTracker(runTracker);
+        vrPlayer.registerTracker(sneakTracker);
+        vrPlayer.registerTracker(swimTracker);
+        vrPlayer.registerTracker(swingTracker);
+        vrPlayer.registerTracker(interactTracker);
+        vrPlayer.registerTracker(teleportTracker);
+        vrPlayer.registerTracker(horseTracker);
+        vrPlayer.registerTracker(vehicleTracker);
+        vrPlayer.registerTracker(physicalGuiManager);
+        vrPlayer.registerTracker(crawlTracker);
+        vrPlayer.registerTracker(cameraTracker);
     }
 
-    public void setMipmapLevels(int mipMapLevel)
-    {
-        this.modelManager.setMaxMipmapLevel(mipMapLevel);
+    private void addRunTickTimeNanos(long runTickTime) {
+        int i = 0;
+        medianRunTickTimeNanos = runTickTime;
+
+        if (this.vrSettings.smoothRunTickCount < 1)
+            this.vrSettings.smoothRunTickCount = 1;
+
+        if (this.vrSettings.smoothRunTickCount % 2 == 0) {
+            // Need an odd number for this
+            this.vrSettings.smoothRunTickCount++;
+        }
+
+        runTickTimeNanos.addFirst(runTickTime);
+        while (runTickTimeNanos.size() > this.vrSettings.smoothRunTickCount)
+            runTickTimeNanos.removeLast();
+
+        if (runTickTimeNanos.size() == this.vrSettings.smoothRunTickCount) {
+            Long[] array = new Long[runTickTimeNanos.size()];
+            for (Iterator itr = runTickTimeNanos.iterator(); itr.hasNext(); i++) {
+                array[i] = (Long) itr.next();
+            }
+            Arrays.sort(array);
+            medianRunTickTimeNanos = array[array.length / 2];
+        }
     }
 
-    public static final class PackManager implements AutoCloseable
-    {
+    private long getMedianRunTickTimeNanos() {
+        return medianRunTickTimeNanos;
+    }
+
+    public void triggerYawTransition(boolean isPositive) {
+        // this.lookaimController.triggerYawTransition(isPositive);
+    }
+
+    public void print(String s) {
+        s = s.replace("\n", "\n[Minecrift] ");
+        System.out.println("[Minecrift] " + s);
+    }
+
+    private void renderSingleView(int eye, float nano, boolean renderworld) {
+
+        GlStateManager.clearColor(0, 0, 0, 1f);
+        GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+        GlStateManager.enableTexture();
+        GlStateManager.enableDepthTest();
+
+        this.profiler.startSection("updateCameraAndRender");
+        // Forge calls onRenderTickStart > move to rungameloop
+
+        /// THIS IS WHERE EVERYTHING IS RENDERED
+        this.gameRenderer.updateCameraAndRender(nano, System.nanoTime(), renderworld);
+
+        // Forge calls onRenderTickEnd > move to rungameloop
+        this.profiler.endSection();
+        checkGLError("post game render " + eye);
+
+        if (currentPass == RenderPass.LEFT || currentPass == RenderPass.RIGHT) {
+            // copies the rendered scene to eye tex with fsaa and other postprocessing
+            // effects.
+            this.profiler.startSection("postprocesseye");
+
+            Framebuffer source = this.framebuffer;
+
+            if (this.vrSettings.useFsaa) {
+                this.profiler.startSection("fsaa");
+                stereoProvider.doFSAA(Config.isShaders());
+                source = stereoProvider.fsaaLastPassResultFBO;
+                checkGLError("fsaa " + eye);
+                this.profiler.endSection();
+            }
+
+            if (currentPass == RenderPass.LEFT)
+                stereoProvider.framebufferEye0.bindFramebuffer(true); // draw to L eye tex
+            else
+                stereoProvider.framebufferEye1.bindFramebuffer(true); // draw to R eye tex
+
+            if (vrSettings.useFOVReduction && vrPlayer.getFreeMove()) {
+                if (player != null && (Math.abs(player.moveForward) > 0 || Math.abs(player.moveStrafing) > 0)) {
+                    fov -= 0.05;
+                    if (fov < vrSettings.fovReductionMin)
+                        fov = vrSettings.fovReductionMin;
+                } else {
+                    fov += 0.01;
+                    if (fov > 0.8)
+                        fov = 0.8f;
+                }
+            } else {
+                fov = 1f;
+            }
+
+            ARBShaderObjects.glUseProgramObjectARB(VRShaders._FOVReduction_shaderProgramId);
+            ARBShaderObjects.glUniform1iARB(VRShaders._FOVReduction_TextureUniform, 0);
+            ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_OffsetUniform, vrSettings.fovRedutioncOffset);
+
+            // VIVE start - screen flash when hurt instead of view tilt
+            float r = 0, k = 0;
+            // VIVE start - screen flash when hurt instead of view tilt
+            float time = (float) Util.milliTime() / 1000;
+            if (player != null && world != null) {
+
+                if (gameRenderer.wasinwater != gameRenderer.inwater) {
+                    watereffect = 2.3f;
+                } else {
+                    if (gameRenderer.inwater) {
+                        watereffect -= (1f / 120f);
+                    } else {
+                        watereffect -= (1f / 60f);
+                    }
+                    if (watereffect < 0)
+                        watereffect = 0;
+                }
+
+                gameRenderer.wasinwater = gameRenderer.inwater;
+
+                if (Config.isShaders())
+                    watereffect = 0; // dont stack.
+
+                if (gameRenderer.inportal) {
+                    portaleffect = 1f;
+                } else {
+                    portaleffect -= (1f / 60f);
+                    if (portaleffect < 0)
+                        portaleffect = 0;
+                }
+
+                ItemStack headItem = player.inventory.armorItemInSlot(3);
+                if (headItem.getItem() == Blocks.CARVED_PUMPKIN.asItem() && (!headItem.hasTag() || headItem.getTag().getInt("CustomModelData") == 0)) {
+                    pumpkineffect = 1f;
+                }
+
+                float var3 = (float) player.hurtTime - nano;
+
+                float percent = 1 - player.getHealth() / player.getMaxHealth();
+                percent = (percent - 0.5f) * 0.75f;
+
+                if (var3 > 0.0f) {
+                    var3 /= (float) player.maxHurtTime;
+                    var3 = percent + MathHelper.sin(var3 * var3 * var3 * var3 * (float) Math.PI) * 0.5f;
+                    r = var3;
+                } else {
+                    r = (float) (percent * Math.abs(Math.sin(2.5f * time / (1 - percent + .1))));
+                    if (player.isCreative())
+                        r = 0;
+                }
+
+//				if (gameRenderer.inblock && player.isAlive()) {
+//					// k = (float) gameRenderer.itemRenderer.inBlock;
+//				}
+
+                if (player.isSleeping()) {
+                    if (k < 0.8)
+                        k = .8f;
+                }
+
+                if (MCOpenVR.isWalkingAbout) {
+                    if (k < 0.8)
+                        k = .5f;
+                }
+
+            } else {
+                watereffect = 0;
+                portaleffect = 0;
+                pumpkineffect = 0;
+            }
+
+            if (pumpkineffect > 0) {
+                ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, 0.3f);
+                ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.0f);
+            } else {
+                ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, fov);
+                ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.06f);
+            }
+
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_HealthAlpha, r);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_BlackAlpha, k);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_time, time);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_waterAmplitude, watereffect);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_portalAmplitutde, portaleffect);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_pumpkinAmplitutde, pumpkineffect);
+            ARBShaderObjects.glUniform1iARB(VRShaders._Overlay_eye, currentPass == RenderPass.LEFT ? 1 : -1);
+
+            source.framebufferRender(stereoProvider.framebufferEye0.framebufferWidth,
+                    stereoProvider.framebufferEye0.framebufferHeight);
+
+            ARBShaderObjects.glUseProgramObjectARB(0);
+
+            checkGLError("post overlay" + eye);
+
+            this.profiler.endSection();
+
+            // this.mcProfiler.startSection("OpenGL Finish");
+            // GL11.glFinish();//DO NOT LEAVE THIS UNCOMMENTED
+            // this.mcProfiler.endSection();
+
+        }
+
+        if (currentPass == RenderPass.CAMERA) {
+            this.profiler.startSection("cameracopy");
+            stereoProvider.cameraFramebuffer.bindFramebuffer(true);
+            GlStateManager.clearColor(0, 0, 0, 1f);
+            GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+            stereoProvider.cameraRenderFramebuffer.framebufferRenderExt(0, stereoProvider.cameraFramebuffer.framebufferWidth, stereoProvider.cameraFramebuffer.framebufferHeight, 0, true, 0, 0, false);
+            this.profiler.endSection();
+        }
+    }
+
+    public float getFrameDelta() {
+        return frameDelta;
+    }
+    //
+
+    // FORGE
+    public ItemColors getItemColors() {
+        return this.itemColors;
+    }
+
+    public SearchTreeManager getSearchTreeManager() {
+        return this.searchTreeManager;
+    }
+
+    public void loadClassPath() {
+        File resourceRoot = new File("../src/resources");
+        if (!resourceRoot.exists() || !resourceRoot.isDirectory())
+            return;
+        Method method;
+        try {
+            method = URLClassLoader.class.getDeclaredMethod("addURL", URL.class);
+            method.setAccessible(true);
+            method.invoke(ClassLoader.getSystemClassLoader(), resourceRoot.toURI().toURL());
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+    }
+
+    public void notifyMirror(String text, boolean clear, int lengthMs) {
+        mirroNotifyStart = System.currentTimeMillis();
+        mirroNotifyLen = lengthMs;
+        mirrorNotifyText = text;
+        mirrorNotifyClear = clear;
+    }
+
+    private void drawNotifyMirror() {
+        if (System.currentTimeMillis() < mirroNotifyStart + mirroNotifyLen) {
+
+            RenderSystem.viewport(0, 0, mainWindow.getWidth(), mainWindow.getHeight());
+            RenderSystem.matrixMode(5889);
+            RenderSystem.loadIdentity();
+            RenderSystem.ortho(0.0D, (double) mainWindow.getWidth() / 4, (double) mainWindow.getHeight() / 4, 0.0D, -10, 10);
+            RenderSystem.matrixMode(5888);
+            RenderSystem.loadIdentity();
+            RenderSystem.clear(256, Minecraft.IS_RUNNING_ON_MAC);
+
+            RenderSystem.fogMode(FogMode.EXP2); //dont ask
+            RenderSystem.fogDensity(0); //dont ask
+            RenderSystem.disableFog(); //ask why this does nothing
+
+            if (mirrorNotifyClear) {
+                RenderSystem.clearColor(0, 0, 0, 0);
+                RenderSystem.clear(GL11.GL_COLOR_BUFFER_BIT, Minecraft.IS_RUNNING_ON_MAC);
+            }
+
+            final int TEXT_WORDWRAP_LEN = mainWindow.getWidth() / 22;
+            ArrayList<String> wrapped = new ArrayList<>();
+            if (mirrorNotifyText != null)
+                org.vivecraft.utils.Utils.wordWrap(mirrorNotifyText, TEXT_WORDWRAP_LEN, wrapped);
+            int column = 1;
+            final int COLUMN_GAP = 12;
+            for (String line : wrapped) {
+                fontRenderer.drawString(new MatrixStack(), line, 1, column, /*white*/16777215);
+                column += COLUMN_GAP;
+            }
+
+        }
+    }
+
+    enum WorldSelectionType {
+        NONE,
+        CREATE,
+        BACKUP
+    }
+
+    public static final class PackManager implements AutoCloseable {
         private final ResourcePackList resourcePackList;
         private final DataPackRegistries datapackRegistries;
         private final IServerConfiguration serverConfiguration;
 
-        private PackManager(ResourcePackList resourcePackList, DataPackRegistries datapackRegistries, IServerConfiguration serverConfiguration)
-        {
+        private PackManager(ResourcePackList resourcePackList, DataPackRegistries datapackRegistries, IServerConfiguration serverConfiguration) {
             this.resourcePackList = resourcePackList;
             this.datapackRegistries = datapackRegistries;
             this.serverConfiguration = serverConfiguration;
         }
 
-        public ResourcePackList getResourcePacks()
-        {
+        public ResourcePackList getResourcePacks() {
             return this.resourcePackList;
         }
 
-        public DataPackRegistries getDataPackRegistries()
-        {
+        public DataPackRegistries getDataPackRegistries() {
             return this.datapackRegistries;
         }
 
-        public IServerConfiguration getServerConfiguration()
-        {
+        public IServerConfiguration getServerConfiguration() {
             return this.serverConfiguration;
         }
 
-        public void close()
-        {
+        public void close() {
             this.resourcePackList.close();
             this.datapackRegistries.close();
         }
     }
 
-    static enum WorldSelectionType
-    {
-        NONE,
-        CREATE,
-        BACKUP;
-    }
 }
